var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/kaplay/dist/kaboom.mjs
var Mi = Object.defineProperty;
var o = (t, e) => Mi(t, "name", { value: e, configurable: true });
var zr = (() => {
  for (var t = new Uint8Array(128), e = 0; e < 64; e++) t[e < 26 ? e + 65 : e < 52 ? e + 71 : e < 62 ? e - 4 : e * 4 - 205] = e;
  return (n) => {
    for (var s = n.length, a = new Uint8Array((s - (n[s - 1] == "=") - (n[s - 2] == "=")) * 3 / 4 | 0), c = 0, h = 0; c < s; ) {
      var b = t[n.charCodeAt(c++)], p = t[n.charCodeAt(c++)], l = t[n.charCodeAt(c++)], M = t[n.charCodeAt(c++)];
      a[h++] = b << 2 | p >> 4, a[h++] = p << 4 | l >> 2, a[h++] = l << 6 | M;
    }
    return a;
  };
})();
function ve(t) {
  return t * Math.PI / 180;
}
o(ve, "deg2rad");
function ht(t) {
  return t * 180 / Math.PI;
}
o(ht, "rad2deg");
function tt(t, e, n) {
  return e > n ? tt(t, n, e) : Math.min(Math.max(t, e), n);
}
o(tt, "clamp");
function nt(t, e, n) {
  if (typeof t == "number" && typeof e == "number") return t + (e - t) * n;
  if (t instanceof B && e instanceof B) return t.lerp(e, n);
  if (t instanceof oe && e instanceof oe) return t.lerp(e, n);
  throw new Error(`Bad value for lerp(): ${t}, ${e}. Only number, Vec2 and Color is supported.`);
}
o(nt, "lerp");
function st(t, e, n, s, a) {
  return s + (t - e) / (n - e) * (a - s);
}
o(st, "map");
function Xr(t, e, n, s, a) {
  return tt(st(t, e, n, s, a), s, a);
}
o(Xr, "mapc");
var _a;
var B = (_a = class {
  constructor(e = 0, n = e) {
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    this.x = e, this.y = n;
  }
  static fromAngle(e) {
    let n = ve(e);
    return new _a(Math.cos(n), Math.sin(n));
  }
  clone() {
    return new _a(this.x, this.y);
  }
  add(...e) {
    let n = E(...e);
    return new _a(this.x + n.x, this.y + n.y);
  }
  sub(...e) {
    let n = E(...e);
    return new _a(this.x - n.x, this.y - n.y);
  }
  scale(...e) {
    let n = E(...e);
    return new _a(this.x * n.x, this.y * n.y);
  }
  dist(...e) {
    let n = E(...e);
    return this.sub(n).len();
  }
  sdist(...e) {
    let n = E(...e);
    return this.sub(n).slen();
  }
  len() {
    return Math.sqrt(this.dot(this));
  }
  slen() {
    return this.dot(this);
  }
  unit() {
    let e = this.len();
    return e === 0 ? new _a(0) : this.scale(1 / e);
  }
  normal() {
    return new _a(this.y, -this.x);
  }
  reflect(e) {
    return this.sub(e.scale(2 * this.dot(e)));
  }
  project(e) {
    return e.scale(e.dot(this) / e.len());
  }
  reject(e) {
    return this.sub(this.project(e));
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  angle(...e) {
    let n = E(...e);
    return ht(Math.atan2(this.y - n.y, this.x - n.x));
  }
  angleBetween(...e) {
    let n = E(...e);
    return ht(Math.atan2(this.cross(n), this.dot(n)));
  }
  lerp(e, n) {
    return new _a(nt(this.x, e.x, n), nt(this.y, e.y, n));
  }
  slerp(e, n) {
    let s = this.dot(e), a = this.cross(e), c = Math.atan2(a, s);
    return this.scale(Math.sin((1 - n) * c)).add(e.scale(Math.sin(n * c))).scale(1 / a);
  }
  isZero() {
    return this.x === 0 && this.y === 0;
  }
  toFixed(e) {
    return new _a(Number(this.x.toFixed(e)), Number(this.y.toFixed(e)));
  }
  transform(e) {
    return e.multVec2(this);
  }
  eq(e) {
    return this.x === e.x && this.y === e.y;
  }
  bbox() {
    return new ce(this, 0, 0);
  }
  toString() {
    return `vec2(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`;
  }
}, o(_a, "Vec2"), __publicField(_a, "LEFT", new _a(-1, 0)), __publicField(_a, "RIGHT", new _a(1, 0)), __publicField(_a, "UP", new _a(0, -1)), __publicField(_a, "DOWN", new _a(0, 1)), _a);
function E(...t) {
  if (t.length === 1) {
    if (t[0] instanceof B) return new B(t[0].x, t[0].y);
    if (Array.isArray(t[0]) && t[0].length === 2) return new B(...t[0]);
  }
  return new B(...t);
}
o(E, "vec2");
var _a2;
var oe = (_a2 = class {
  constructor(e, n, s) {
    __publicField(this, "r", 255);
    __publicField(this, "g", 255);
    __publicField(this, "b", 255);
    this.r = tt(e, 0, 255), this.g = tt(n, 0, 255), this.b = tt(s, 0, 255);
  }
  static fromArray(e) {
    return new _a2(e[0], e[1], e[2]);
  }
  static fromHex(e) {
    if (typeof e == "number") return new _a2(e >> 16 & 255, e >> 8 & 255, e >> 0 & 255);
    if (typeof e == "string") {
      let n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
      return new _a2(parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16));
    } else throw new Error("Invalid hex color format");
  }
  static fromHSL(e, n, s) {
    if (n == 0) return new _a2(255 * s, 255 * s, 255 * s);
    let a = o((M, y, P) => (P < 0 && (P += 1), P > 1 && (P -= 1), P < 1 / 6 ? M + (y - M) * 6 * P : P < 1 / 2 ? y : P < 2 / 3 ? M + (y - M) * (2 / 3 - P) * 6 : M), "hue2rgb"), c = s < 0.5 ? s * (1 + n) : s + n - s * n, h = 2 * s - c, b = a(h, c, e + 1 / 3), p = a(h, c, e), l = a(h, c, e - 1 / 3);
    return new _a2(Math.round(b * 255), Math.round(p * 255), Math.round(l * 255));
  }
  clone() {
    return new _a2(this.r, this.g, this.b);
  }
  lighten(e) {
    return new _a2(this.r + e, this.g + e, this.b + e);
  }
  darken(e) {
    return this.lighten(-e);
  }
  invert() {
    return new _a2(255 - this.r, 255 - this.g, 255 - this.b);
  }
  mult(e) {
    return new _a2(this.r * e.r / 255, this.g * e.g / 255, this.b * e.b / 255);
  }
  lerp(e, n) {
    return new _a2(nt(this.r, e.r, n), nt(this.g, e.g, n), nt(this.b, e.b, n));
  }
  toHSL() {
    let e = this.r / 255, n = this.g / 255, s = this.b / 255, a = Math.max(e, n, s), c = Math.min(e, n, s), h = (a + c) / 2, b = h, p = h;
    if (a == c) h = b = 0;
    else {
      let l = a - c;
      switch (b = p > 0.5 ? l / (2 - a - c) : l / (a + c), a) {
        case e:
          h = (n - s) / l + (n < s ? 6 : 0);
          break;
        case n:
          h = (s - e) / l + 2;
          break;
        case s:
          h = (e - n) / l + 4;
          break;
      }
      h /= 6;
    }
    return [h, b, p];
  }
  eq(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b;
  }
  toString() {
    return `rgb(${this.r}, ${this.g}, ${this.b})`;
  }
  toHex() {
    return "#" + ((1 << 24) + (this.r << 16) + (this.g << 8) + this.b).toString(16).slice(1);
  }
  toArray() {
    return [this.r, this.g, this.b];
  }
}, o(_a2, "Color"), __publicField(_a2, "RED", new _a2(255, 0, 0)), __publicField(_a2, "GREEN", new _a2(0, 255, 0)), __publicField(_a2, "BLUE", new _a2(0, 0, 255)), __publicField(_a2, "YELLOW", new _a2(255, 255, 0)), __publicField(_a2, "MAGENTA", new _a2(255, 0, 255)), __publicField(_a2, "CYAN", new _a2(0, 255, 255)), __publicField(_a2, "WHITE", new _a2(255, 255, 255)), __publicField(_a2, "BLACK", new _a2(0, 0, 0)), _a2);
function ie(...t) {
  if (t.length === 0) return new oe(255, 255, 255);
  if (t.length === 1) {
    if (t[0] instanceof oe) return t[0].clone();
    if (typeof t[0] == "string") return oe.fromHex(t[0]);
    if (Array.isArray(t[0]) && t[0].length === 3) return oe.fromArray(t[0]);
  }
  return new oe(...t);
}
o(ie, "rgb");
var Yr = o((t, e, n) => oe.fromHSL(t, e, n), "hsl2rgb");
var _a3;
var he = (_a3 = class {
  constructor(e, n, s, a) {
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "w", 1);
    __publicField(this, "h", 1);
    this.x = e, this.y = n, this.w = s, this.h = a;
  }
  scale(e) {
    return new _a3(this.x + this.w * e.x, this.y + this.h * e.y, this.w * e.w, this.h * e.h);
  }
  pos() {
    return new B(this.x, this.y);
  }
  clone() {
    return new _a3(this.x, this.y, this.w, this.h);
  }
  eq(e) {
    return this.x === e.x && this.y === e.y && this.w === e.w && this.h === e.h;
  }
  toString() {
    return `quad(${this.x}, ${this.y}, ${this.w}, ${this.h})`;
  }
}, o(_a3, "Quad"), _a3);
function ge(t, e, n, s) {
  return new he(t, e, n, s);
}
o(ge, "quad");
var _a4;
var Gt = (_a4 = class {
  constructor(e, n, s, a) {
    __publicField(this, "a");
    __publicField(this, "b");
    __publicField(this, "c");
    __publicField(this, "d");
    this.a = e, this.b = n, this.c = s, this.d = a;
  }
  mul(e) {
    return new _a4(this.a * e.a + this.b * e.c, this.a * e.b + this.b * e.d, this.c * e.a + this.d * e.c, this.c * e.b + this.d * e.d);
  }
  transform(e) {
    return E(this.a * e.x + this.b * e.y, this.c * e.x + this.d * e.y);
  }
  get inverse() {
    let e = this.det;
    return new _a4(this.d / e, -this.b / e, -this.c / e, this.a / e);
  }
  get transpose() {
    return new _a4(this.a, this.c, this.b, this.d);
  }
  get eigenvalues() {
    let e = this.trace / 2, n = this.det, s = e + Math.sqrt(e * e - n), a = e - Math.sqrt(e * e - n);
    return [s, a];
  }
  eigenvectors(e, n) {
    return this.c != 0 ? [[e - this.d, this.c], [n - this.d, this.c]] : this.b != 0 ? [[this.b, e - this.a], [this.b, n - this.a]] : Math.abs(this.transform(E(1, 0)).x - e) < Number.EPSILON ? [[1, 0], [0, 1]] : [[0, 1], [1, 0]];
  }
  get det() {
    return this.a * this.d - this.b * this.c;
  }
  get trace() {
    return this.a + this.d;
  }
  static rotation(e) {
    let n = Math.cos(e), s = Math.sin(e);
    return new _a4(n, s, -s, n);
  }
  static scale(e, n) {
    return new _a4(e, 0, 0, n);
  }
}, o(_a4, "Mat2"), _a4);
var _a5;
var Tt = (_a5 = class {
  constructor(e, n, s, a, c, h, b, p, l) {
    __publicField(this, "m11");
    __publicField(this, "m12");
    __publicField(this, "m13");
    __publicField(this, "m21");
    __publicField(this, "m22");
    __publicField(this, "m23");
    __publicField(this, "m31");
    __publicField(this, "m32");
    __publicField(this, "m33");
    this.m11 = e, this.m12 = n, this.m13 = s, this.m21 = a, this.m22 = c, this.m23 = h, this.m31 = b, this.m32 = p, this.m33 = l;
  }
  static fromMat2(e) {
    return new _a5(e.a, e.b, 0, e.c, e.d, 0, 0, 0, 1);
  }
  toMat2() {
    return new Gt(this.m11, this.m12, this.m21, this.m22);
  }
  mul(e) {
    return new _a5(this.m11 * e.m11 + this.m12 * e.m21 + this.m13 * e.m31, this.m11 * e.m12 + this.m12 * e.m22 + this.m13 * e.m32, this.m11 * e.m13 + this.m12 * e.m23 + this.m13 * e.m33, this.m21 * e.m11 + this.m22 * e.m21 + this.m23 * e.m31, this.m21 * e.m12 + this.m22 * e.m22 + this.m23 * e.m32, this.m21 * e.m13 + this.m22 * e.m23 + this.m23 * e.m33, this.m31 * e.m11 + this.m32 * e.m21 + this.m33 * e.m31, this.m31 * e.m12 + this.m32 * e.m22 + this.m33 * e.m32, this.m31 * e.m13 + this.m32 * e.m23 + this.m33 * e.m33);
  }
  get det() {
    return this.m11 * this.m22 * this.m33 + this.m12 * this.m23 * this.m31 + this.m13 * this.m21 * this.m32 - this.m13 * this.m22 * this.m31 - this.m12 * this.m21 * this.m33 - this.m11 * this.m23 * this.m32;
  }
  rotate(e) {
    let n = Math.cos(e), s = Math.sin(e), a = this.m11, c = this.m12;
    return this.m11 = n * this.m11 + s * this.m21, this.m12 = n * this.m12 + s * this.m22, this.m21 = n * this.m21 - s * a, this.m22 = n * this.m22 - s * c, this;
  }
  scale(e, n) {
    return this.m11 *= e, this.m12 *= e, this.m21 *= n, this.m22 *= n, this;
  }
  get inverse() {
    let e = this.det;
    return new _a5((this.m22 * this.m33 - this.m23 * this.m32) / e, (this.m13 * this.m32 - this.m12 * this.m33) / e, (this.m12 * this.m23 - this.m13 * this.m22) / e, (this.m23 * this.m31 - this.m21 * this.m33) / e, (this.m11 * this.m33 - this.m13 * this.m31) / e, (this.m13 * this.m21 - this.m11 * this.m23) / e, (this.m21 * this.m32 - this.m22 * this.m31) / e, (this.m12 * this.m31 - this.m11 * this.m32) / e, (this.m11 * this.m22 - this.m12 * this.m21) / e);
  }
  get transpose() {
    return new _a5(this.m11, this.m21, this.m31, this.m12, this.m22, this.m32, this.m13, this.m23, this.m33);
  }
}, o(_a5, "Mat3"), _a5);
var _a6;
var Le = (_a6 = class {
  constructor(e) {
    __publicField(this, "m", [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    e && (this.m = e);
  }
  static translate(e) {
    return new _a6([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e.x, e.y, 0, 1]);
  }
  static scale(e) {
    return new _a6([e.x, 0, 0, 0, 0, e.y, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  static rotateX(e) {
    e = ve(-e);
    let n = Math.cos(e), s = Math.sin(e);
    return new _a6([1, 0, 0, 0, 0, n, -s, 0, 0, s, n, 0, 0, 0, 0, 1]);
  }
  static rotateY(e) {
    e = ve(-e);
    let n = Math.cos(e), s = Math.sin(e);
    return new _a6([n, 0, s, 0, 0, 1, 0, 0, -s, 0, n, 0, 0, 0, 0, 1]);
  }
  static rotateZ(e) {
    e = ve(-e);
    let n = Math.cos(e), s = Math.sin(e);
    return new _a6([n, -s, 0, 0, s, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  translate(e) {
    return this.m[12] += this.m[0] * e.x + this.m[4] * e.y, this.m[13] += this.m[1] * e.x + this.m[5] * e.y, this.m[14] += this.m[2] * e.x + this.m[6] * e.y, this.m[15] += this.m[3] * e.x + this.m[7] * e.y, this;
  }
  scale(e) {
    return this.m[0] *= e.x, this.m[4] *= e.y, this.m[1] *= e.x, this.m[5] *= e.y, this.m[2] *= e.x, this.m[6] *= e.y, this.m[3] *= e.x, this.m[7] *= e.y, this;
  }
  rotate(e) {
    e = ve(-e);
    let n = Math.cos(e), s = Math.sin(e), a = this.m[0], c = this.m[1], h = this.m[4], b = this.m[5];
    return this.m[0] = a * n + c * s, this.m[1] = -a * s + c * n, this.m[4] = h * n + b * s, this.m[5] = -h * s + b * n, this;
  }
  mult(e) {
    let n = [];
    for (let s = 0; s < 4; s++) for (let a = 0; a < 4; a++) n[s * 4 + a] = this.m[0 * 4 + a] * e.m[s * 4 + 0] + this.m[1 * 4 + a] * e.m[s * 4 + 1] + this.m[2 * 4 + a] * e.m[s * 4 + 2] + this.m[3 * 4 + a] * e.m[s * 4 + 3];
    return new _a6(n);
  }
  multVec2(e) {
    return new B(e.x * this.m[0] + e.y * this.m[4] + this.m[12], e.x * this.m[1] + e.y * this.m[5] + this.m[13]);
  }
  getTranslation() {
    return new B(this.m[12], this.m[13]);
  }
  getScale() {
    if (this.m[0] != 0 || this.m[1] != 0) {
      let e = this.m[0] * this.m[5] - this.m[1] * this.m[4], n = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);
      return new B(n, e / n);
    } else if (this.m[4] != 0 || this.m[5] != 0) {
      let e = this.m[0] * this.m[5] - this.m[1] * this.m[4], n = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5]);
      return new B(e / n, n);
    } else return new B(0, 0);
  }
  getRotation() {
    if (this.m[0] != 0 || this.m[1] != 0) {
      let e = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);
      return ht(this.m[1] > 0 ? Math.acos(this.m[0] / e) : -Math.acos(this.m[0] / e));
    } else if (this.m[4] != 0 || this.m[5] != 0) {
      let e = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5]);
      return ht(Math.PI / 2 - (this.m[5] > 0 ? Math.acos(-this.m[4] / e) : -Math.acos(this.m[4] / e)));
    } else return 0;
  }
  getSkew() {
    if (this.m[0] != 0 || this.m[1] != 0) {
      let e = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);
      return new B(Math.atan(this.m[0] * this.m[4] + this.m[1] * this.m[5]) / (e * e), 0);
    } else if (this.m[4] != 0 || this.m[5] != 0) {
      let e = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5]);
      return new B(0, Math.atan(this.m[0] * this.m[4] + this.m[1] * this.m[5]) / (e * e));
    } else return new B(0, 0);
  }
  invert() {
    let e = [], n = this.m[10] * this.m[15] - this.m[14] * this.m[11], s = this.m[9] * this.m[15] - this.m[13] * this.m[11], a = this.m[9] * this.m[14] - this.m[13] * this.m[10], c = this.m[8] * this.m[15] - this.m[12] * this.m[11], h = this.m[8] * this.m[14] - this.m[12] * this.m[10], b = this.m[8] * this.m[13] - this.m[12] * this.m[9], p = this.m[6] * this.m[15] - this.m[14] * this.m[7], l = this.m[5] * this.m[15] - this.m[13] * this.m[7], M = this.m[5] * this.m[14] - this.m[13] * this.m[6], y = this.m[4] * this.m[15] - this.m[12] * this.m[7], P = this.m[4] * this.m[14] - this.m[12] * this.m[6], v = this.m[5] * this.m[15] - this.m[13] * this.m[7], j = this.m[4] * this.m[13] - this.m[12] * this.m[5], H = this.m[6] * this.m[11] - this.m[10] * this.m[7], Q = this.m[5] * this.m[11] - this.m[9] * this.m[7], N = this.m[5] * this.m[10] - this.m[9] * this.m[6], J = this.m[4] * this.m[11] - this.m[8] * this.m[7], A = this.m[4] * this.m[10] - this.m[8] * this.m[6], te = this.m[4] * this.m[9] - this.m[8] * this.m[5];
    e[0] = this.m[5] * n - this.m[6] * s + this.m[7] * a, e[4] = -(this.m[4] * n - this.m[6] * c + this.m[7] * h), e[8] = this.m[4] * s - this.m[5] * c + this.m[7] * b, e[12] = -(this.m[4] * a - this.m[5] * h + this.m[6] * b), e[1] = -(this.m[1] * n - this.m[2] * s + this.m[3] * a), e[5] = this.m[0] * n - this.m[2] * c + this.m[3] * h, e[9] = -(this.m[0] * s - this.m[1] * c + this.m[3] * b), e[13] = this.m[0] * a - this.m[1] * h + this.m[2] * b, e[2] = this.m[1] * p - this.m[2] * l + this.m[3] * M, e[6] = -(this.m[0] * p - this.m[2] * y + this.m[3] * P), e[10] = this.m[0] * v - this.m[1] * y + this.m[3] * j, e[14] = -(this.m[0] * M - this.m[1] * P + this.m[2] * j), e[3] = -(this.m[1] * H - this.m[2] * Q + this.m[3] * N), e[7] = this.m[0] * H - this.m[2] * J + this.m[3] * A, e[11] = -(this.m[0] * Q - this.m[1] * J + this.m[3] * te), e[15] = this.m[0] * N - this.m[1] * A + this.m[2] * te;
    let W = this.m[0] * e[0] + this.m[1] * e[4] + this.m[2] * e[8] + this.m[3] * e[12];
    for (let se = 0; se < 4; se++) for (let ne = 0; ne < 4; ne++) e[se * 4 + ne] *= 1 / W;
    return new _a6(e);
  }
  clone() {
    return new _a6([...this.m]);
  }
  toString() {
    return this.m.toString();
  }
}, o(_a6, "Mat4"), _a6);
function sr(t, e, n, s = (a) => -Math.cos(a)) {
  return t + (s(n) + 1) / 2 * (e - t);
}
o(sr, "wave");
var Bi = 1103515245;
var Gi = 12345;
var Wr = 2147483648;
var _a7;
var Xt = (_a7 = class {
  constructor(e) {
    __publicField(this, "seed");
    this.seed = e;
  }
  gen() {
    return this.seed = (Bi * this.seed + Gi) % Wr, this.seed / Wr;
  }
  genNumber(e, n) {
    return e + this.gen() * (n - e);
  }
  genVec2(e, n) {
    return new B(this.genNumber(e.x, n.x), this.genNumber(e.y, n.y));
  }
  genColor(e, n) {
    return new oe(this.genNumber(e.r, n.r), this.genNumber(e.g, n.g), this.genNumber(e.b, n.b));
  }
  genAny(...e) {
    if (e.length === 0) return this.gen();
    if (e.length === 1) {
      if (typeof e[0] == "number") return this.genNumber(0, e[0]);
      if (e[0] instanceof B) return this.genVec2(E(0, 0), e[0]);
      if (e[0] instanceof oe) return this.genColor(ie(0, 0, 0), e[0]);
    } else if (e.length === 2) {
      if (typeof e[0] == "number" && typeof e[1] == "number") return this.genNumber(e[0], e[1]);
      if (e[0] instanceof B && e[1] instanceof B) return this.genVec2(e[0], e[1]);
      if (e[0] instanceof oe && e[1] instanceof oe) return this.genColor(e[0], e[1]);
    }
  }
}, o(_a7, "RNG"), _a7);
var or = new Xt(Date.now());
function $r(t) {
  return t != null && (or.seed = t), or.seed;
}
o($r, "randSeed");
function Yt(...t) {
  return or.genAny(...t);
}
o(Yt, "rand");
function ir(...t) {
  return Math.floor(Yt(...t));
}
o(ir, "randi");
function Qr(t) {
  return Yt() <= t;
}
o(Qr, "chance");
function ar(t) {
  for (let e = t.length - 1; e > 0; e--) {
    let n = Math.floor(Math.random() * (e + 1));
    [t[e], t[n]] = [t[n], t[e]];
  }
  return t;
}
o(ar, "shuffle");
function Jr(t, e) {
  return t.length <= e ? t.slice() : ar(t.slice()).slice(0, e);
}
o(Jr, "chooseMultiple");
function Zr(t) {
  return t[ir(t.length)];
}
o(Zr, "choose");
function ur(t, e) {
  return t.pos.x + t.width > e.pos.x && t.pos.x < e.pos.x + e.width && t.pos.y + t.height > e.pos.y && t.pos.y < e.pos.y + e.height;
}
o(ur, "testRectRect");
function Fi(t, e) {
  if (t.p1.x === t.p2.x && t.p1.y === t.p2.y || e.p1.x === e.p2.x && e.p1.y === e.p2.y) return null;
  let n = (e.p2.y - e.p1.y) * (t.p2.x - t.p1.x) - (e.p2.x - e.p1.x) * (t.p2.y - t.p1.y);
  if (n === 0) return null;
  let s = ((e.p2.x - e.p1.x) * (t.p1.y - e.p1.y) - (e.p2.y - e.p1.y) * (t.p1.x - e.p1.x)) / n, a = ((t.p2.x - t.p1.x) * (t.p1.y - e.p1.y) - (t.p2.y - t.p1.y) * (t.p1.x - e.p1.x)) / n;
  return s < 0 || s > 1 || a < 0 || a > 1 ? null : s;
}
o(Fi, "testLineLineT");
function vn(t, e) {
  let n = Fi(t, e);
  return n ? E(t.p1.x + n * (t.p2.x - t.p1.x), t.p1.y + n * (t.p2.y - t.p1.y)) : null;
}
o(vn, "testLineLine");
function xn(t, e) {
  let n = e.p2.sub(e.p1), s = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY;
  if (n.x != 0) {
    let c = (t.pos.x - e.p1.x) / n.x, h = (t.pos.x + t.width - e.p1.x) / n.x;
    s = Math.max(s, Math.min(c, h)), a = Math.min(a, Math.max(c, h));
  }
  if (n.y != 0) {
    let c = (t.pos.y - e.p1.y) / n.y, h = (t.pos.y + t.height - e.p1.y) / n.y;
    s = Math.max(s, Math.min(c, h)), a = Math.min(a, Math.max(c, h));
  }
  return a >= s && a >= 0 && s <= 1;
}
o(xn, "testRectLine");
function cr(t, e) {
  return e.x > t.pos.x && e.x < t.pos.x + t.width && e.y > t.pos.y && e.y < t.pos.y + t.height;
}
o(cr, "testRectPoint");
function eo(t, e) {
  let n = Math.max(t.pos.x, Math.min(e.center.x, t.pos.x + t.width)), s = Math.max(t.pos.y, Math.min(e.center.y, t.pos.y + t.height));
  return E(n, s).sdist(e.center) <= e.radius * e.radius;
}
o(eo, "testRectCircle");
function to(t, e) {
  return no(e, new Pe(t.points()));
}
o(to, "testRectPolygon");
function lr(t, e) {
  let n = e.sub(t.p1), s = t.p2.sub(t.p1);
  if (Math.abs(n.cross(s)) > Number.EPSILON) return false;
  let a = n.dot(s) / s.dot(s);
  return a >= 0 && a <= 1;
}
o(lr, "testLinePoint");
function Ft(t, e) {
  let n = t.p2.sub(t.p1), s = n.dot(n), a = t.p1.sub(e.center), c = 2 * n.dot(a), h = a.dot(a) - e.radius * e.radius, b = c * c - 4 * s * h;
  if (s <= Number.EPSILON || b < 0) return false;
  if (b == 0) {
    let p = -c / (2 * s);
    if (p >= 0 && p <= 1) return true;
  } else {
    let p = (-c + Math.sqrt(b)) / (2 * s), l = (-c - Math.sqrt(b)) / (2 * s);
    if (p >= 0 && p <= 1 || l >= 0 && l <= 1) return true;
  }
  return dr(e, t.p1);
}
o(Ft, "testLineCircle");
function mr(t, e) {
  if (pt(e, t.p1) || pt(e, t.p2)) return true;
  for (let n = 0; n < e.pts.length; n++) {
    let s = e.pts[n], a = e.pts[(n + 1) % e.pts.length];
    if (vn(t, new je(s, a))) return true;
  }
  return false;
}
o(mr, "testLinePolygon");
function dr(t, e) {
  return t.center.sdist(e) < t.radius * t.radius;
}
o(dr, "testCirclePoint");
function Ii(t, e) {
  return t.center.sdist(e.center) < (t.radius + e.radius) * (t.radius + e.radius);
}
o(Ii, "testCircleCircle");
function $t(t, e) {
  let n = e.pts[e.pts.length - 1];
  for (let s of e.pts) {
    if (Ft(new je(n, s), t)) return true;
    n = s;
  }
  return dr(t, e.pts[0]) ? true : pt(e, t.center);
}
o($t, "testCirclePolygon");
function no(t, e) {
  for (let n = 0; n < t.pts.length; n++) if (mr(new je(t.pts[n], t.pts[(n + 1) % t.pts.length]), e)) return true;
  return !!(t.pts.some((n) => pt(e, n)) || e.pts.some((n) => pt(t, n)));
}
o(no, "testPolygonPolygon");
function pt(t, e) {
  let n = false, s = t.pts;
  for (let a = 0, c = s.length - 1; a < s.length; c = a++) s[a].y > e.y != s[c].y > e.y && e.x < (s[c].x - s[a].x) * (e.y - s[a].y) / (s[c].y - s[a].y) + s[a].x && (n = !n);
  return n;
}
o(pt, "testPolygonPoint");
function ro(t, e) {
  e = e.sub(t.center);
  let n = ve(t.angle), s = Math.cos(n), a = Math.sin(n), c = e.x * s + e.y * a, h = -e.x * a + e.y * s;
  return c * c / (t.radiusX * t.radiusX) + h * h / (t.radiusY * t.radiusY) < 1;
}
o(ro, "testEllipsePoint");
function yn(t, e) {
  let n = e.center.sub(t.center), s = ve(t.angle), a = Math.cos(s), c = Math.sin(s), h = n.x * a + n.y * c, b = -n.x * c + n.y * a;
  return ro(new Qe(E(), t.radiusX + e.radius, t.radiusY + e.radius, 0), E(h, b));
}
o(yn, "testEllipseCircle");
function oo(t, e) {
  let n = t.toMat2().inverse;
  return e = new je(n.transform(e.p1.sub(t.center)), n.transform(e.p2.sub(t.center))), Ft(e, new ke(E(), 1));
}
o(oo, "testEllipseLine");
function Li(t, e) {
  if (t.radiusX === t.radiusY) return yn(e, new ke(t.center, t.radiusX));
  if (e.radiusX === e.radiusY) return yn(t, new ke(e.center, e.radiusX));
  let n = new Tt(1 / t.radiusX ** 2, 0, 0, 0, 1 / t.radiusY ** 2, 0, 0, 0, -1), s = new Tt(1 / e.radiusX ** 2, 0, 0, 0, 1 / e.radiusY ** 2, 0, 0, 0, -1), a = t.center.x, c = t.center.y, h = e.center.x, b = e.center.y, p = ve(t.angle), l = ve(e.angle), M = new Tt(Math.cos(p), -Math.sin(p), a, Math.sin(p), Math.cos(p), c, 0, 0, 1), y = new Tt(Math.cos(l), -Math.sin(l), h, Math.sin(l), Math.cos(l), b, 0, 0, 1), P = M.inverse, v = y.inverse, j = P.transpose.mul(n).mul(P), H = v.transpose.mul(s).mul(v), Q = j.m11, N = j.m12, J = j.m13, A = j.m21, te = j.m22, W = j.m23, se = j.m31, ne = j.m32, ae = j.m33, le = H.m11, we = H.m12, be = H.m13, Oe = H.m21, ye = H.m22, Ke = H.m23, qe = H.m31, ze = H.m32, We = H.m33, ft = Q * te * ae - Q * W * ne - N * A * ae + N * W * se + J * A * ne - J * te * se, Ae = (Q * te * We - Q * W * ze - Q * ne * Ke + Q * ae * ye - N * A * We + N * W * qe + N * se * Ke - N * ae * Oe + J * A * ze - J * te * qe - J * se * ye + J * ne * Oe + A * ne * be - A * ae * we - te * se * be + te * ae * le + W * se * we - W * ne * le) / ft, Ue = (Q * ye * We - Q * Ke * ze - N * Oe * We + N * Ke * qe + J * Oe * ze - J * ye * qe - A * we * We + A * be * ze + te * le * We - te * be * qe - W * le * ze + W * we * qe + se * we * Ke - se * be * ye - ne * le * Ke + ne * be * Oe + ae * le * ye - ae * we * Oe) / ft, Ne = (le * ye * We - le * Ke * ze - we * Oe * We + we * Ke * qe + be * Oe * ze - be * ye * qe) / ft;
  if (Ae >= 0) {
    let ct = -3 * Ue + Ae ** 2, Ye = 3 * Ae * Ne + Ue * Ae ** 2 - 4 * Ue ** 2, Vt = -27 * Ne ** 2 + 18 * Ne * Ae * Ue + Ae ** 2 * Ue ** 2 - 4 * Ae ** 3 * Ne - 4 * Ue ** 3;
    return !(ct > 0 && Ye < 0 && Vt > 0);
  } else {
    let ct = -3 * Ue + Ae ** 2, Ye = -27 * Ne ** 2 + 18 * Ne * Ae * Ue + Ae ** 2 * Ue ** 2 - 4 * Ae ** 3 * Ne - 4 * Ue ** 3;
    return !(ct > 0 && Ye > 0);
  }
}
o(Li, "testEllipseEllipse");
function so(t, e) {
  return hr(t, new Pe(e.points()));
}
o(so, "testEllipseRect");
function hr(t, e) {
  let n = t.toMat2().inverse;
  return e = new Pe(e.pts.map((s) => n.transform(s.sub(t.center)))), $t(new ke(E(), 1), e);
}
o(hr, "testEllipsePolygon");
function ji(t, e) {
  return e instanceof B ? lr(t, e) : e instanceof ke ? Ft(t, e) : e instanceof je ? vn(t, e) != null : e instanceof ce ? xn(e, t) : e instanceof Pe ? mr(t, e) : e instanceof Qe ? oo(e, t) : false;
}
o(ji, "testLineShape");
function ki(t, e) {
  return e instanceof B ? dr(t, e) : e instanceof ke ? Ii(t, e) : e instanceof je ? Ft(e, t) : e instanceof ce ? eo(e, t) : e instanceof Pe ? $t(t, e) : e instanceof Qe ? yn(e, t) : false;
}
o(ki, "testCircleShape");
function Ni(t, e) {
  return e instanceof B ? cr(t, e) : e instanceof ke ? eo(t, e) : e instanceof je ? xn(t, e) : e instanceof ce ? ur(t, e) : e instanceof Pe ? to(t, e) : e instanceof Qe ? so(e, t) : false;
}
o(Ni, "testRectShape");
function _i(t, e) {
  return e instanceof B ? pt(t, e) : e instanceof ke ? $t(e, t) : e instanceof je ? mr(e, t) : e instanceof ce ? to(e, t) : e instanceof Pe ? no(e, t) : e instanceof Qe ? hr(e, t) : false;
}
o(_i, "testPolygonShape");
function Hi(t, e) {
  return e instanceof B ? ro(t, e) : e instanceof ke ? yn(t, e) : e instanceof je ? oo(t, e) : e instanceof ce ? so(t, e) : e instanceof Pe ? hr(t, e) : e instanceof Qe ? Li(e, t) : false;
}
o(Hi, "testEllipseShape");
function io(t, e, n) {
  let s = t, a = n.p1, c = n.p2, h = e, b = c.sub(a), p = h.cross(b);
  if (Math.abs(p) < Number.EPSILON) return null;
  let l = a.sub(s), M = l.cross(b) / p;
  if (M <= 0 || M >= 1) return null;
  let y = l.cross(h) / p;
  if (y <= 0 || y >= 1) return null;
  let P = b.normal().unit();
  return e.dot(P) > 0 && (P.x *= -1, P.y *= -1), { point: s.add(h.scale(M)), normal: P, fraction: M };
}
o(io, "raycastLine");
function Ki(t, e, n) {
  let s = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY, c;
  if (t.x != 0) {
    let h = (n.pos.x - t.x) / e.x, b = (n.pos.x + n.width - t.x) / e.x;
    c = E(-Math.sign(e.x), 0), s = Math.max(s, Math.min(h, b)), a = Math.min(a, Math.max(h, b));
  }
  if (t.y != 0) {
    let h = (n.pos.y - t.y) / e.y, b = (n.pos.y + n.height - t.y) / e.y;
    Math.min(h, b) > s && (c = E(0, -Math.sign(e.y))), s = Math.max(s, Math.min(h, b)), a = Math.min(a, Math.max(h, b));
  }
  return a >= s && s >= 0 && s <= 1 ? { point: t.add(e.scale(s)), normal: c, fraction: s } : null;
}
o(Ki, "raycastRect");
function ao(t, e, n) {
  let s = t, a = n.center, c = e, h = c.dot(c), b = s.sub(a), p = 2 * c.dot(b), l = b.dot(b) - n.radius * n.radius, M = p * p - 4 * h * l;
  if (h <= Number.EPSILON || M < 0) return null;
  if (M == 0) {
    let y = -p / (2 * h);
    if (y >= 0 && y <= 1) {
      let P = s.add(c.scale(y));
      return { point: P, normal: P.sub(a), fraction: y };
    }
  } else {
    let y = (-p + Math.sqrt(M)) / (2 * h), P = (-p - Math.sqrt(M)) / (2 * h), v = null;
    if (y >= 0 && y <= 1 && (v = y), P >= 0 && P <= 1 && (v = Math.min(P, v ?? P)), v != null) {
      let j = s.add(c.scale(v));
      return { point: j, normal: j.sub(a).unit(), fraction: v };
    }
  }
  return null;
}
o(ao, "raycastCircle");
function qi(t, e, n) {
  let s = n.pts, a = null, c = s[s.length - 1];
  for (let h = 0; h < s.length; h++) {
    let b = s[h], p = io(t, e, new je(c, b));
    p && (!a || a.fraction > p.fraction) && (a = p), c = b;
  }
  return a;
}
o(qi, "raycastPolygon");
function zi(t, e, n) {
  let s = n.toMat2(), a = s.inverse, c = a.transform(t.sub(n.center)), h = a.transform(e), b = ao(c, h, new ke(E(), 1));
  if (b) {
    let p = Gt.rotation(ve(-n.angle)), M = Gt.scale(n.radiusX, n.radiusY).transform(b.point), y = s.transform(b.point).add(n.center), P = y.dist(t) / e.len();
    return { point: y, normal: p.transform(E(n.radiusY ** 2 * M.x, n.radiusX ** 2 * M.y)), fraction: P };
  }
  return b;
}
o(zi, "raycastEllipse");
function uo(t, e, n, s = 64) {
  let a = t, c = e.len(), h = e.scale(1 / c), b = 0, p = E(Math.floor(t.x), Math.floor(t.y)), l = E(h.x > 0 ? 1 : -1, h.y > 0 ? 1 : -1), M = E(Math.abs(1 / h.x), Math.abs(1 / h.y)), y = E(l.x > 0 ? p.x + 1 - t.x : t.x - p.x, l.y > 0 ? p.y + 1 - t.y : t.y - p.y), P = E(M.x < 1 / 0 ? M.x * y.x : 1 / 0, M.y < 1 / 0 ? M.y * y.y : 1 / 0), v = -1;
  for (; b <= s; ) {
    let j = n(p);
    if (j === true) return { point: a.add(h.scale(b)), normal: E(v === 0 ? -l.x : 0, v === 1 ? -l.y : 0), fraction: b / c, gridPos: p };
    if (j) return j;
    P.x < P.y ? (p.x += l.x, b = P.x, P.x += M.x, v = 0) : (p.y += l.y, b = P.y, P.y += M.y, v = 1);
  }
  return null;
}
o(uo, "raycastGrid");
var _a8;
var je = (_a8 = class {
  constructor(e, n) {
    __publicField(this, "p1");
    __publicField(this, "p2");
    this.p1 = e.clone(), this.p2 = n.clone();
  }
  transform(e) {
    return new _a8(e.multVec2(this.p1), e.multVec2(this.p2));
  }
  bbox() {
    return ce.fromPoints(this.p1, this.p2);
  }
  area() {
    return this.p1.dist(this.p2);
  }
  clone() {
    return new _a8(this.p1, this.p2);
  }
  collides(e) {
    return ji(this, e);
  }
  contains(e) {
    return this.collides(e);
  }
  raycast(e, n) {
    return io(e, n, this);
  }
}, o(_a8, "Line"), _a8);
var _a9;
var ce = (_a9 = class {
  constructor(e, n, s) {
    __publicField(this, "pos");
    __publicField(this, "width");
    __publicField(this, "height");
    this.pos = e.clone(), this.width = n, this.height = s;
  }
  static fromPoints(e, n) {
    return new _a9(e.clone(), n.x - e.x, n.y - e.y);
  }
  center() {
    return new B(this.pos.x + this.width / 2, this.pos.y + this.height / 2);
  }
  points() {
    return [this.pos, this.pos.add(this.width, 0), this.pos.add(this.width, this.height), this.pos.add(0, this.height)];
  }
  transform(e) {
    return new Pe(this.points().map((n) => e.multVec2(n)));
  }
  bbox() {
    return this.clone();
  }
  area() {
    return this.width * this.height;
  }
  clone() {
    return new _a9(this.pos.clone(), this.width, this.height);
  }
  distToPoint(e) {
    return Math.sqrt(this.sdistToPoint(e));
  }
  sdistToPoint(e) {
    let n = this.pos, s = this.pos.add(this.width, this.height), a = Math.max(n.x - e.x, 0, e.x - s.x), c = Math.max(n.y - e.y, 0, e.y - s.y);
    return a * a + c * c;
  }
  collides(e) {
    return Ni(this, e);
  }
  contains(e) {
    return this.collides(e);
  }
  raycast(e, n) {
    return Ki(e, n, this);
  }
}, o(_a9, "Rect"), _a9);
var _a10;
var ke = (_a10 = class {
  constructor(e, n) {
    __publicField(this, "center");
    __publicField(this, "radius");
    this.center = e.clone(), this.radius = n;
  }
  transform(e) {
    return new Qe(this.center, this.radius, this.radius).transform(e);
  }
  bbox() {
    return ce.fromPoints(this.center.sub(E(this.radius)), this.center.add(E(this.radius)));
  }
  area() {
    return this.radius * this.radius * Math.PI;
  }
  clone() {
    return new _a10(this.center, this.radius);
  }
  collides(e) {
    return ki(this, e);
  }
  contains(e) {
    return this.collides(e);
  }
  raycast(e, n) {
    return ao(e, n, this);
  }
}, o(_a10, "Circle"), _a10);
var _a11;
var Qe = (_a11 = class {
  constructor(e, n, s, a = 0) {
    __publicField(this, "center");
    __publicField(this, "radiusX");
    __publicField(this, "radiusY");
    __publicField(this, "angle");
    this.center = e.clone(), this.radiusX = n, this.radiusY = s, this.angle = a;
  }
  static fromMat2(e) {
    let n = e.inverse, s = n.transpose.mul(n), [a, c] = s.eigenvalues, [h, b] = s.eigenvectors(a, c), [p, l] = [1 / Math.sqrt(a), 1 / Math.sqrt(c)];
    return p > l ? new _a11(E(), p, l, ht(Math.atan2(-h[1], h[0]))) : new _a11(E(), l, p, ht(Math.atan2(-b[1], b[0])));
  }
  toMat2() {
    let e = ve(this.angle), n = Math.cos(e), s = Math.sin(e);
    return new Gt(n * this.radiusX, s * this.radiusY, -s * this.radiusX, n * this.radiusY);
  }
  transform(e) {
    if (this.angle == 0 && e.getRotation() == 0) return new _a11(e.multVec2(this.center), e.m[0] * this.radiusX, e.m[5] * this.radiusY);
    {
      let n = this.toMat2(), s = e.getRotation(), a = e.getScale();
      n = Tt.fromMat2(n).scale(a.x, a.y).rotate(s).toMat2();
      let h = _a11.fromMat2(n);
      return h.center = e.multVec2(this.center), h;
    }
  }
  bbox() {
    if (this.angle == 0) return ce.fromPoints(this.center.sub(E(this.radiusX, this.radiusY)), this.center.add(E(this.radiusX, this.radiusY)));
    {
      let e = ve(this.angle), n = Math.cos(e), s = Math.sin(e), a = this.radiusX * n, c = this.radiusX * s, h = this.radiusY * s, b = this.radiusY * n, p = Math.sqrt(a * a + h * h), l = Math.sqrt(c * c + b * b);
      return ce.fromPoints(this.center.sub(E(p, l)), this.center.add(E(p, l)));
    }
  }
  area() {
    return this.radiusX * this.radiusY * Math.PI;
  }
  clone() {
    return new _a11(this.center, this.radiusX, this.radiusY, this.angle);
  }
  collides(e) {
    return Hi(this, e);
  }
  contains(e) {
    e = e.sub(this.center);
    let n = ve(this.angle), s = Math.cos(n), a = Math.sin(n), c = e.x * s + e.y * a, h = -e.x * a + e.y * s;
    return c * c / (this.radiusX * this.radiusX) + h * h / (this.radiusY * this.radiusY) < 1;
  }
  raycast(e, n) {
    return zi(e, n, this);
  }
}, o(_a11, "Ellipse"), _a11);
var _a12;
var Pe = (_a12 = class {
  constructor(e) {
    __publicField(this, "pts");
    if (e.length < 3) throw new Error("Polygons should have at least 3 vertices");
    this.pts = e;
  }
  transform(e) {
    return new _a12(this.pts.map((n) => e.multVec2(n)));
  }
  bbox() {
    let e = E(Number.MAX_VALUE), n = E(-Number.MAX_VALUE);
    for (let s of this.pts) e.x = Math.min(e.x, s.x), n.x = Math.max(n.x, s.x), e.y = Math.min(e.y, s.y), n.y = Math.max(n.y, s.y);
    return ce.fromPoints(e, n);
  }
  area() {
    let e = 0, n = this.pts.length;
    for (let s = 0; s < n; s++) {
      let a = this.pts[s], c = this.pts[(s + 1) % n];
      e += a.x * c.y * 0.5, e -= c.x * a.y * 0.5;
    }
    return Math.abs(e);
  }
  clone() {
    return new _a12(this.pts.map((e) => e.clone()));
  }
  collides(e) {
    return _i(this, e);
  }
  contains(e) {
    return this.collides(e);
  }
  raycast(e, n) {
    return qi(e, n, this);
  }
}, o(_a12, "Polygon"), _a12);
function co(t, e, n, s) {
  let a = s * s, c = 1 - s, h = c * c;
  return t.scale(h).add(e.scale(2 * c * s)).add(n.scale(a));
}
o(co, "evaluateQuadratic");
function lo(t, e, n, s) {
  let a = 1 - s;
  return e.sub(t).scale(2 * a).add(n.sub(e).scale(2 * s));
}
o(lo, "evaluateQuadraticFirstDerivative");
function mo(t, e, n, s) {
  return n.sub(e.scale(2)).add(t).scale(2);
}
o(mo, "evaluateQuadraticSecondDerivative");
function wn(t, e, n, s, a) {
  let c = a * a, h = c * a, b = 1 - a, p = b * b, l = p * b;
  return t.scale(l).add(e.scale(3 * p * a)).add(n.scale(3 * b * c)).add(s.scale(h));
}
o(wn, "evaluateBezier");
function ho(t, e, n, s, a) {
  let c = a * a, h = 1 - a, b = h * h;
  return e.sub(t).scale(3 * b).add(n.sub(e).scale(6 * h * a)).add(s.sub(n).scale(3 * c));
}
o(ho, "evaluateBezierFirstDerivative");
function po(t, e, n, s, a) {
  let c = 1 - a;
  return n.sub(e.scale(2)).add(t).scale(6 * c).add(s.sub(n.scale(2)).add(e).scale(6 * a));
}
o(po, "evaluateBezierSecondDerivative");
function fo(t, e, n, s, a) {
  let c = 0.5 * (((-a + 2) * a - 1) * a), h = 0.5 * ((3 * a - 5) * a * a + 2), b = 0.5 * (((-3 * a + 4) * a + 1) * a), p = 0.5 * ((a - 1) * a * a);
  return t.scale(c).add(e.scale(h)).add(n.scale(b)).add(s.scale(p));
}
o(fo, "evaluateCatmullRom");
function go(t, e, n, s, a) {
  let c = 0.5 * ((-3 * a + 4) * a - 1), h = 0.5 * ((9 * a - 10) * a), b = 0.5 * ((-9 * a + 8) * a + 1), p = 0.5 * ((3 * a - 2) * a);
  return t.scale(c).add(e.scale(h)).add(n.scale(b)).add(s.scale(p));
}
o(go, "evaluateCatmullRomFirstDerivative");
function bo(t) {
  let e = pr(t), n = e(1);
  return (s) => {
    let a = s * n, c = e(a, true);
    return t(c);
  };
}
o(bo, "normalizedCurve");
function pr(t, e = 10, n = 10) {
  let s = [0], a = [0], h = 1 / (e - 1) / n, b = 0, p = t(0), l = 0;
  for (let M = 1; M < e; M++) {
    for (let y = 0; y < n; y++) {
      l += h;
      let P = t(l), v = P.dist(p);
      b += v, p = P;
    }
    s[M] = b, a[M] = l;
  }
  return a[e - 1] = 1, (M, y = false) => {
    if (y) {
      let P = M;
      if (P <= 0) return 0;
      if (P >= b) return 1;
      let v = 0;
      for (; s[v + 1] < P; ) v++;
      let j = a[v], H = a[v + 1], Q = s[v], N = s[v + 1], J = (P - Q) / (N - Q);
      return j + (H - j) * J;
    } else {
      if (M <= 0) return 0;
      if (M >= 1) return s[e - 1];
      let P = 0;
      for (; a[P + 1] < M; ) P++;
      let v = a[P], j = a[P + 1], H = s[P], Q = s[P + 1], N = (M - v) / (j - v);
      return H + (Q - H) * N;
    }
  };
}
o(pr, "curveLengthApproximation");
function zt(t) {
  return 0 <= t && t <= 1;
}
o(zt, "inZeroOneDomain");
function nr(t, e) {
  return Math.abs(t - e) <= Number.EPSILON;
}
o(nr, "approximately");
function Wt(t) {
  return t < 0 ? -Math.pow(-t, 1 / 3) : Math.pow(t, 1 / 3);
}
o(Wt, "cubeRoot");
function Wi(t, e, n, s) {
  let a = 3 * t - 6 * e + 3 * n, c = -3 * t + 3 * e, h = t, b = -t + 3 * e - 3 * n + s;
  if (nr(b, 0)) {
    if (nr(a, 0)) return nr(c, 0) ? [] : [-h / c].filter(zt);
    let N = Math.sqrt(c * c - 4 * a * h), J = 2 * a;
    return [(N - c) / J, (-c - N) / J].filter(zt);
  }
  a /= b, c /= b, h /= b;
  let p = (3 * c - a * a) / 3, l = p / 3, M = (2 * a * a * a - 9 * a * c + 27 * h) / 27, y = M / 2, P = y * y + l * l * l;
  if (P < 0) {
    let N = -p / 3, J = N * N * N, A = Math.sqrt(J), te = -M / (2 * A), W = te < -1 ? -1 : te > 1 ? 1 : te, se = Math.acos(W), ae = 2 * Wt(A), le = ae * Math.cos(se / 3) - a / 3, we = ae * Math.cos((se + 2 * Math.PI) / 3) - a / 3, be = ae * Math.cos((se + 4 * Math.PI) / 3) - a / 3;
    return [le, we, be].filter(zt);
  }
  if (P === 0) {
    let N = y < 0 ? Wt(-y) : -Wt(y), J = 2 * N - a / 3, A = -N - a / 3;
    return [J, A].filter(zt);
  }
  let v = Math.sqrt(P), j = Wt(v - y), H = Wt(v + y);
  return [j - H - a / 3].filter(zt);
}
o(Wi, "getCubicRoots");
function Xi(t, e, n, s, a) {
  let c = Wi(t.x - a, e.x - a, n.x - a, s.x - a);
  return c.length > 0 ? wn(t, e, n, s, c[0]).y : NaN;
}
o(Xi, "cubicBezierYforX");
function yo(t) {
  if (!t || t.length == 0) throw new Error("Need at least one point for easingLinear.");
  let e = t.length;
  return (n) => {
    if (n <= 0 || t.length == 1 || n <= t[0].x) return t[0].y;
    for (let s = 0; s < e; s++) if (t[s].x >= n) return st(n, t[s - 1].x, t[s].x, t[s - 1].y, t[s].y);
    return t[t.length - 1].y;
  };
}
o(yo, "easingLinear");
function vo(t, e) {
  return (n) => Xi(E(0, 0), t, e, E(1, 1), n);
}
o(vo, "easingCubicBezier");
function xo(t, e = "jump-end") {
  let n = 1 / t, s = e == "jump-start" || e == "jump-both", a = e == "jump-end" || e == "jump-both", c = 1 / (t + (a ? 1 : 0)), h = s ? c : 0;
  return (b) => {
    let p = Math.floor(b / n);
    return h + p * c;
  };
}
o(xo, "easingSteps");
function wo(t, e) {
  let n = Number.MAX_VALUE, s = E(0);
  for (let a of [t, e]) for (let c = 0; c < a.pts.length; c++) {
    let h = a.pts[c], p = a.pts[(c + 1) % a.pts.length].sub(h).normal().unit(), l = Number.MAX_VALUE, M = -Number.MAX_VALUE;
    for (let j = 0; j < t.pts.length; j++) {
      let H = t.pts[j].dot(p);
      l = Math.min(l, H), M = Math.max(M, H);
    }
    let y = Number.MAX_VALUE, P = -Number.MAX_VALUE;
    for (let j = 0; j < e.pts.length; j++) {
      let H = e.pts[j].dot(p);
      y = Math.min(y, H), P = Math.max(P, H);
    }
    let v = Math.min(M, P) - Math.max(l, y);
    if (v < 0) return null;
    if (v < Math.abs(n)) {
      let j = P - l, H = y - M;
      n = Math.abs(j) < Math.abs(H) ? j : H, s = p.scale(n);
    }
  }
  return s;
}
o(wo, "sat");
function Co(t, e, n) {
  return (e.x - t.x) * (n.y - t.y) - (e.y - t.y) * (n.x - t.x) >= 0;
}
o(Co, "isOrientedCcw");
function Yi(t) {
  let e = 0, n = t[t.length - 1];
  for (let s = 0; s < t.length; s++) e += (t[s].x - n.x) * (t[s].y + n.y), n = t[s];
  return e < 0;
}
o(Yi, "isOrientedCcwPolygon");
function rr(t, e, n, s) {
  let a = s.x - n.x, c = s.y - n.y, h = a * (t.y - n.y) - c * (t.x - n.x), b = a * (e.y - n.y) - c * (e.x - n.x);
  return h * b >= 0;
}
o(rr, "onSameSide");
function $i(t, e, n, s) {
  return rr(t, e, n, s) && rr(t, n, e, s) && rr(t, s, e, n);
}
o($i, "pointInTriangle");
function Qi(t, e, n, s) {
  for (let a of t) if (a !== e && a !== n && a !== s && $i(a, e, n, s)) return true;
  return false;
}
o(Qi, "someInTriangle");
function Ji(t, e, n, s) {
  return Co(t, e, n) && !Qi(s, t, e, n);
}
o(Ji, "isEar");
function fr(t) {
  if (t.length < 3) return [];
  if (t.length == 3) return [t];
  let e = [], n = [], s = 0;
  for (let y = 0; y < t.length; y++) {
    let P = t[s], v = t[y];
    (v.x < P.x || v.x == P.x && v.y < P.y) && (s = s), e[y] = y + 1, n[y] = y - 1;
  }
  e[e.length - 1] = 0, n[0] = n.length - 1, Yi(t) || ([e, n] = [n, e]);
  let a = [];
  for (let y = 0; y < t.length; ++y) Co(t[n[y]], t[y], t[e[y]]) || a.push(t[y]);
  let c = [], h = t.length, b = 1, p = 0, l, M;
  for (; h > 3; ) {
    l = e[b], M = n[b];
    let y = t[M], P = t[b], v = t[l];
    if (Ji(y, P, v, a)) c.push([y, P, v]), e[M] = l, n[l] = M, a.splice(a.indexOf(P), 1), --h, p = 0;
    else if (++p > h) return [];
    b = l;
  }
  return l = e[b], M = n[b], c.push([t[M], t[b], t[l]]), c;
}
o(fr, "triangulate");
function To(t) {
  if (t.length < 3) return false;
  let e = t.length - 2, n = t.length - 1, s = 0, a = t[n].sub(t[e]), c = t[s].sub(t[n]), h = a.cross(c);
  for (; s + 1 < t.length; ) if (e = n, n = s, s++, a = t[n].sub(t[e]), c = t[s].sub(t[n]), a.cross(c) * h < 0) return false;
  return true;
}
o(To, "isConvex");
var _a13;
var Qt = (_a13 = class extends Map {
  constructor() {
    super(...arguments);
    __publicField(this, "lastID", 0);
  }
  push(e) {
    let n = this.lastID;
    return this.set(n, e), this.lastID++, n;
  }
  pushd(e) {
    let n = this.push(e);
    return () => this.delete(n);
  }
}, o(_a13, "Registry"), _a13);
var _a14;
var it = (_a14 = class {
  constructor(e) {
    __publicField(this, "paused", false);
    __publicField(this, "cancel");
    this.cancel = e;
  }
  static join(e) {
    let n = new _a14(() => e.forEach((s) => s.cancel()));
    return Object.defineProperty(n, "paused", { get: o(() => e[0].paused, "get"), set: o((s) => e.forEach((a) => a.paused = s), "set") }), n.paused = false, n;
  }
}, o(_a14, "EventController"), _a14);
var _a15;
var Se = (_a15 = class {
  constructor() {
    __publicField(this, "handlers", new Qt());
  }
  add(e) {
    let n = this.handlers.pushd((...a) => {
      s.paused || e(...a);
    }), s = new it(n);
    return s;
  }
  addOnce(e) {
    let n = this.add((...s) => {
      n.cancel(), e(...s);
    });
    return n;
  }
  next() {
    return new Promise((e) => this.addOnce(e));
  }
  trigger(...e) {
    this.handlers.forEach((n) => n(...e));
  }
  numListeners() {
    return this.handlers.size;
  }
  clear() {
    this.handlers.clear();
  }
}, o(_a15, "Event"), _a15);
var _a16;
var at = (_a16 = class {
  constructor() {
    __publicField(this, "handlers", {});
  }
  on(e, n) {
    return this.handlers[e] || (this.handlers[e] = new Se()), this.handlers[e].add(n);
  }
  onOnce(e, n) {
    let s = this.on(e, (...a) => {
      s.cancel(), n(...a);
    });
    return s;
  }
  next(e) {
    return new Promise((n) => {
      this.onOnce(e, (...s) => n(s[0]));
    });
  }
  trigger(e, ...n) {
    this.handlers[e] && this.handlers[e].trigger(...n);
  }
  remove(e) {
    delete this.handlers[e];
  }
  clear() {
    this.handlers = {};
  }
  numListeners(e) {
    var _a29;
    return ((_a29 = this.handlers[e]) == null ? void 0 : _a29.numListeners()) ?? 0;
  }
}, o(_a16, "EventHandler"), _a16);
function Tn(t, e) {
  if (t === e) return true;
  let n = typeof t, s = typeof e;
  if (n !== s) return false;
  if (n === "object" && s === "object" && t !== null && e !== null) {
    if (Array.isArray(t) !== Array.isArray(e)) return false;
    let a = Object.keys(t), c = Object.keys(e);
    if (a.length !== c.length) return false;
    for (let h of a) {
      let b = t[h], p = e[h];
      if (!Tn(b, p)) return false;
    }
    return true;
  }
  return false;
}
o(Tn, "deepEq");
function Zi(t) {
  let e = window.atob(t), n = e.length, s = new Uint8Array(n);
  for (let a = 0; a < n; a++) s[a] = e.charCodeAt(a);
  return s.buffer;
}
o(Zi, "base64ToArrayBuffer");
function Eo(t) {
  return Zi(t.split(",")[1]);
}
o(Eo, "dataURLToArrayBuffer");
function Sn(t, e) {
  let n = document.createElement("a");
  n.href = e, n.download = t, n.click();
}
o(Sn, "download");
function gr(t, e) {
  Sn(t, "data:text/plain;charset=utf-8," + e);
}
o(gr, "downloadText");
function Oo(t, e) {
  gr(t, JSON.stringify(e));
}
o(Oo, "downloadJSON");
function br(t, e) {
  let n = URL.createObjectURL(e);
  Sn(t, n), URL.revokeObjectURL(n);
}
o(br, "downloadBlob");
var yr = o((t) => t.match(/^data:\w+\/\w+;base64,.+/), "isDataURL");
var Ao = o((t) => t.split(".").slice(0, -1).join("."), "getFileName");
function xe(t, e) {
  return (...n) => {
    let s = n.length;
    if (s === t.length) return t(...n);
    if (s === e.length) return e(...n);
  };
}
o(xe, "overload2");
var Ro = /* @__PURE__ */ (() => {
  let t = 0;
  return () => t++;
})();
var Po = o((t) => t instanceof Error ? t.message : String(t), "getErrorMessage");
var _a17;
var Cn = (_a17 = class {
  constructor(e = (n, s) => n < s) {
    __publicField(this, "_items");
    __publicField(this, "_compareFn");
    this._compareFn = e, this._items = [];
  }
  insert(e) {
    this._items.push(e), this.moveUp(this._items.length - 1);
  }
  remove() {
    if (this._items.length === 0) return null;
    let e = this._items[0], n = this._items.pop();
    return this._items.length !== 0 && (this._items[0] = n, this.moveDown(0)), e;
  }
  clear() {
    this._items.splice(0, this._items.length);
  }
  moveUp(e) {
    for (; e > 0; ) {
      let n = Math.floor((e - 1) / 2);
      if (!this._compareFn(this._items[e], this._items[n]) && this._items[e] >= this._items[n]) break;
      this.swap(e, n), e = n;
    }
  }
  moveDown(e) {
    for (; e < Math.floor(this._items.length / 2); ) {
      let n = 2 * e + 1;
      if (n < this._items.length - 1 && !this._compareFn(this._items[n], this._items[n + 1]) && ++n, this._compareFn(this._items[e], this._items[n])) break;
      this.swap(e, n), e = n;
    }
  }
  swap(e, n) {
    [this._items[e], this._items[n]] = [this._items[n], this._items[e]];
  }
  get length() {
    return this._items.length;
  }
}, o(_a17, "BinaryHeap"), _a17);
var ea = Object.freeze([776, 2359, 2367, 2984, 3007, 3021, 3633, 3635, 3648, 3657, 4352, 4449, 4520]);
function Vo(t) {
  if (typeof t != "string") throw new TypeError("string cannot be undefined or null");
  let e = [], n = 0, s = 0;
  for (; n < t.length; ) {
    if (s += ta(n + s, t), ua(t[n + s]) && s++, sa(t[n + s]) && s++, ia(t[n + s]) && s++, ca(t[n + s])) {
      s++;
      continue;
    }
    e.push(t.substring(n, n + s)), n += s, s = 0;
  }
  return e;
}
o(Vo, "runes");
function ta(t, e) {
  let n = e[t];
  if (!na(n) || t === e.length - 1) return 1;
  let s = n + e[t + 1], a = e.substring(t + 2, t + 5);
  return So(s) && So(a) ? 4 : ra(s) && aa(a) ? e.slice(t).indexOf(String.fromCodePoint(917631)) + 2 : oa(a) ? 4 : 2;
}
o(ta, "nextUnits");
function na(t) {
  return t && St(t[0].charCodeAt(0), 55296, 56319);
}
o(na, "isFirstOfSurrogatePair");
function So(t) {
  return St(vr(t), 127462, 127487);
}
o(So, "isRegionalIndicator");
function ra(t) {
  return St(vr(t), 127988, 127988);
}
o(ra, "isSubdivisionFlag");
function oa(t) {
  return St(vr(t), 127995, 127999);
}
o(oa, "isFitzpatrickModifier");
function sa(t) {
  return typeof t == "string" && St(t.charCodeAt(0), 65024, 65039);
}
o(sa, "isVariationSelector");
function ia(t) {
  return typeof t == "string" && St(t.charCodeAt(0), 8400, 8447);
}
o(ia, "isDiacriticalMark");
function aa(t) {
  let e = t.codePointAt(0);
  return typeof t == "string" && typeof e == "number" && St(e, 917504, 917631);
}
o(aa, "isSupplementarySpecialpurposePlane");
function ua(t) {
  return typeof t == "string" && ea.includes(t.charCodeAt(0));
}
o(ua, "isGrapheme");
function ca(t) {
  return typeof t == "string" && t.charCodeAt(0) === 8205;
}
o(ca, "isZeroWidthJoiner");
function vr(t) {
  let e = t.charCodeAt(0) - 55296, n = t.charCodeAt(1) - 56320;
  return (e << 10) + n + 65536;
}
o(vr, "codePointFromSurrogatePair");
function St(t, e, n) {
  return t >= e && t <= n;
}
o(St, "betweenInclusive");
function Uo(t) {
  return (t == null ? void 0 : t.prototype) && Object.getOwnPropertyDescriptor(t.prototype, "constructor") !== void 0;
}
o(Uo, "isClass");
var He = o((t, e) => Array.isArray(t) ? t == null ? void 0 : t.includes(e) : t === e, "isEqOrIncludes");
var Je = o((t, e) => Array.isArray(e) ? e.some((n) => t.has(n)) : t.has(e), "setHasOrIncludes");
var xr = { "Joy-Con L+R (STANDARD GAMEPAD Vendor: 057e Product: 200e)": { buttons: { "0": "south", "1": "east", "2": "west", "3": "north", "4": "lshoulder", "5": "rshoulder", "6": "ltrigger", "7": "rtrigger", "8": "select", "9": "start", "10": "lstick", "11": "rstick", "12": "dpad-up", "13": "dpad-down", "14": "dpad-left", "15": "dpad-right", "16": "home", "17": "capture" }, sticks: { left: { x: 0, y: 1 }, right: { x: 2, y: 3 } } }, "Joy-Con (L) (STANDARD GAMEPAD Vendor: 057e Product: 2006)": { buttons: { "0": "south", "1": "east", "2": "west", "3": "north", "4": "lshoulder", "5": "rshoulder", "9": "select", "10": "lstick", "16": "start" }, sticks: { left: { x: 0, y: 1 } } }, "Joy-Con (R) (STANDARD GAMEPAD Vendor: 057e Product: 2007)": { buttons: { "0": "south", "1": "east", "2": "west", "3": "north", "4": "lshoulder", "5": "rshoulder", "9": "start", "10": "lstick", "16": "select" }, sticks: { left: { x: 0, y: 1 } } }, "Pro Controller (STANDARD GAMEPAD Vendor: 057e Product: 2009)": { buttons: { "0": "south", "1": "east", "2": "west", "3": "north", "4": "lshoulder", "5": "rshoulder", "6": "ltrigger", "7": "rtrigger", "8": "select", "9": "start", "10": "lstick", "11": "rstick", "12": "dpad-up", "13": "dpad-down", "14": "dpad-left", "15": "dpad-right", "16": "home", "17": "capture" }, sticks: { left: { x: 0, y: 1 }, right: { x: 2, y: 3 } } }, default: { buttons: { "0": "south", "1": "east", "2": "west", "3": "north", "4": "lshoulder", "5": "rshoulder", "6": "ltrigger", "7": "rtrigger", "8": "select", "9": "start", "10": "lstick", "11": "rstick", "12": "dpad-up", "13": "dpad-down", "14": "dpad-left", "15": "dpad-right", "16": "home" }, sticks: { left: { x: 0, y: 1 }, right: { x: 2, y: 3 } } } };
var _a18;
var Et = (_a18 = class {
  constructor() {
    __publicField(this, "pressed", /* @__PURE__ */ new Set([]));
    __publicField(this, "pressedRepeat", /* @__PURE__ */ new Set([]));
    __publicField(this, "released", /* @__PURE__ */ new Set([]));
    __publicField(this, "down", /* @__PURE__ */ new Set([]));
  }
  update() {
    this.pressed.clear(), this.released.clear(), this.pressedRepeat.clear();
  }
  press(e) {
    this.pressed.add(e), this.pressedRepeat.add(e), this.down.add(e);
  }
  pressRepeat(e) {
    this.pressedRepeat.add(e);
  }
  release(e) {
    this.down.delete(e), this.pressed.delete(e), this.released.add(e);
  }
}, o(_a18, "ButtonState"), _a18);
var _a19;
var wr = (_a19 = class {
  constructor() {
    __publicField(this, "buttonState", new Et());
    __publicField(this, "stickState", /* @__PURE__ */ new Map());
  }
}, o(_a19, "GamepadState"), _a19);
var _a20;
var Cr = (_a20 = class {
  constructor() {
    __publicField(this, "dts", []);
    __publicField(this, "timer", 0);
    __publicField(this, "fps", 0);
  }
  tick(e) {
    this.dts.push(e), this.timer += e, this.timer >= 1 && (this.timer = 0, this.fps = Math.round(1 / (this.dts.reduce((n, s) => n + s) / this.dts.length)), this.dts = []);
  }
}, o(_a20, "FPSCounter"), _a20);
var Do = o((t) => {
  if (!t.canvas) throw new Error("Please provide a canvas");
  let e = { canvas: t.canvas, buttons: t.buttons ?? {}, loopID: null, stopped: false, dt: 0, time: 0, realTime: 0, fpsCounter: new Cr(), timeScale: 1, skipTime: false, isHidden: false, numFrames: 0, mousePos: new B(0), mouseDeltaPos: new B(0), keyState: new Et(), mouseState: new Et(), mergedGamepadState: new wr(), gamepadStates: /* @__PURE__ */ new Map(), buttonState: new Et(), gamepads: [], charInputted: [], isMouseMoved: false, lastWidth: t.canvas.offsetWidth, lastHeight: t.canvas.offsetHeight, events: new at() };
  function n() {
    return e.dt * e.timeScale;
  }
  o(n, "dt");
  function s() {
    return e.isHidden;
  }
  o(s, "isHidden");
  function a() {
    return e.time;
  }
  o(a, "time");
  function c() {
    return e.fpsCounter.fps;
  }
  o(c, "fps");
  function h() {
    return e.numFrames;
  }
  o(h, "numFrames");
  function b() {
    return e.canvas.toDataURL();
  }
  o(b, "screenshot");
  function p(d) {
    e.canvas.style.cursor = d;
  }
  o(p, "setCursor");
  function l() {
    return e.canvas.style.cursor;
  }
  o(l, "getCursor");
  function M(d) {
    if (d) try {
      let T = e.canvas.requestPointerLock();
      T.catch && T.catch((G) => console.error(G));
    } catch (T) {
      console.error(T);
    }
    else document.exitPointerLock();
  }
  o(M, "setCursorLocked");
  function y() {
    return !!document.pointerLockElement;
  }
  o(y, "isCursorLocked");
  function P(d) {
    d.requestFullscreen ? d.requestFullscreen() : d.webkitRequestFullscreen && d.webkitRequestFullscreen();
  }
  o(P, "enterFullscreen");
  function v() {
    document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullScreen && document.webkitExitFullScreen();
  }
  o(v, "exitFullscreen");
  function j(d = true) {
    d ? P(e.canvas) : v();
  }
  o(j, "setFullscreen");
  function H() {
    return document.fullscreenElement === e.canvas || document.webkitFullscreenElement === e.canvas;
  }
  o(H, "isFullscreen");
  function Q() {
    e.stopped = true;
    for (let d in Ee) e.canvas.removeEventListener(d, Ee[d]);
    for (let d in xt) document.removeEventListener(d, xt[d]);
    for (let d in et) window.removeEventListener(d, et[d]);
    Kt.disconnect();
  }
  o(Q, "quit");
  function N(d) {
    e.loopID !== null && cancelAnimationFrame(e.loopID);
    let T = 0, G = o(($) => {
      if (e.stopped) return;
      if (document.visibilityState !== "visible") {
        e.loopID = requestAnimationFrame(G);
        return;
      }
      let Ce = $ / 1e3, me = Ce - e.realTime, fe = t.maxFPS ? 1 / t.maxFPS : 0;
      e.realTime = Ce, T += me, T > fe && (e.skipTime || (e.dt = T, e.time += n(), e.fpsCounter.tick(e.dt)), T = 0, e.skipTime = false, e.numFrames++, zn(), d(), yt()), e.loopID = requestAnimationFrame(G);
    }, "frame");
    G(0);
  }
  o(N, "run");
  function J() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0;
  }
  o(J, "isTouchscreen");
  function A() {
    return e.mousePos.clone();
  }
  o(A, "mousePos");
  function te() {
    return e.mouseDeltaPos.clone();
  }
  o(te, "mouseDeltaPos");
  function W(d = "left") {
    return e.mouseState.pressed.has(d);
  }
  o(W, "isMousePressed");
  function se(d = "left") {
    return e.mouseState.down.has(d);
  }
  o(se, "isMouseDown");
  function ne(d = "left") {
    return e.mouseState.released.has(d);
  }
  o(ne, "isMouseReleased");
  function ae() {
    return e.isMouseMoved;
  }
  o(ae, "isMouseMoved");
  function le(d) {
    return d === void 0 ? e.keyState.pressed.size > 0 : Je(e.keyState.pressed, d);
  }
  o(le, "isKeyPressed");
  function we(d) {
    return d === void 0 ? e.keyState.pressedRepeat.size > 0 : Je(e.keyState.pressedRepeat, d);
  }
  o(we, "isKeyPressedRepeat");
  function be(d) {
    return d === void 0 ? e.keyState.down.size > 0 : Je(e.keyState.down, d);
  }
  o(be, "isKeyDown");
  function Oe(d) {
    return d === void 0 ? e.keyState.released.size > 0 : Je(e.keyState.released, d);
  }
  o(Oe, "isKeyReleased");
  function ye(d) {
    return d === void 0 ? e.mergedGamepadState.buttonState.pressed.size > 0 : Je(e.mergedGamepadState.buttonState.pressed, d);
  }
  o(ye, "isGamepadButtonPressed");
  function Ke(d) {
    return d === void 0 ? e.mergedGamepadState.buttonState.down.size > 0 : Je(e.mergedGamepadState.buttonState.down, d);
  }
  o(Ke, "isGamepadButtonDown");
  function qe(d) {
    return d === void 0 ? e.mergedGamepadState.buttonState.released.size > 0 : Je(e.mergedGamepadState.buttonState.released, d);
  }
  o(qe, "isGamepadButtonReleased");
  function ze(d) {
    return d === void 0 ? e.buttonState.pressed.size > 0 : Je(e.buttonState.pressed, d);
  }
  o(ze, "isButtonPressed");
  function We(d) {
    return d === void 0 ? e.buttonState.down.size > 0 : Je(e.buttonState.down, d);
  }
  o(We, "isButtonDown");
  function ft(d) {
    return d === void 0 ? e.buttonState.released.size > 0 : Je(e.buttonState.released, d);
  }
  o(ft, "isButtonReleased");
  function Ae(d) {
    var _a29;
    return (_a29 = e.buttons) == null ? void 0 : _a29[d];
  }
  o(Ae, "getButton");
  function Ue(d, T) {
    e.buttons[d] = { ...e.buttons[d], ...T };
  }
  o(Ue, "setButton");
  function Ne(d) {
    var _a29;
    for (let T in e.buttons) if ((((_a29 = e.buttons[T].keyboard) == null ? void 0 : _a29.length) ? e.buttons[T].keyboard : [T]).includes(d)) return Object.keys(e.buttons).find(($) => e.buttons[$] === e.buttons[T]);
  }
  o(Ne, "getButtonNameByKey");
  function ct(d) {
    var _a29;
    for (let T in e.buttons) if ((((_a29 = e.buttons[T].gamepad) == null ? void 0 : _a29.length) ? e.buttons[T].gamepad : [T]).includes(d)) return Object.keys(e.buttons).find(($) => e.buttons[$] === e.buttons[T]);
  }
  o(ct, "getButtonByGamepadButton");
  function Ye(d) {
    var _a29;
    for (let T in e.buttons) if ((((_a29 = e.buttons[T].mouse) == null ? void 0 : _a29.length) ? e.buttons[T].mouse : [T]).includes(d)) return Object.keys(e.buttons).find(($) => e.buttons[$] === e.buttons[T]);
  }
  o(Ye, "getButtonByMouseButton");
  function Vt(d) {
    return e.events.on("resize", d);
  }
  o(Vt, "onResize");
  let un = xe((d) => e.events.on("keyDown", d), (d, T) => e.events.on("keyDown", (G) => He(d, G) && T(G))), Fn = xe((d) => e.events.on("keyPress", (T) => d(T)), (d, T) => e.events.on("keyPress", (G) => He(d, G) && T(G))), cn = xe((d) => e.events.on("keyPressRepeat", d), (d, T) => e.events.on("keyPressRepeat", (G) => He(d, G) && T(G))), In = xe((d) => e.events.on("keyRelease", d), (d, T) => e.events.on("keyRelease", (G) => He(d, G) && T(G))), Ln = xe((d) => e.events.on("mouseDown", (T) => d(T)), (d, T) => e.events.on("mouseDown", (G) => He(d, G) && T(G))), ln = xe((d) => e.events.on("mousePress", (T) => d(T)), (d, T) => e.events.on("mousePress", (G) => He(d, G) && T(G))), jn = xe((d) => e.events.on("mouseRelease", (T) => d(T)), (d, T) => e.events.on("mouseRelease", (G) => G === d && T(G)));
  function kn(d) {
    return e.events.on("mouseMove", () => d(A(), te()));
  }
  o(kn, "onMouseMove");
  function mn(d) {
    return e.events.on("charInput", d);
  }
  o(mn, "onCharInput");
  function dn(d) {
    return e.events.on("touchStart", d);
  }
  o(dn, "onTouchStart");
  function Nn(d) {
    return e.events.on("touchMove", d);
  }
  o(Nn, "onTouchMove");
  function jt(d) {
    return e.events.on("touchEnd", d);
  }
  o(jt, "onTouchEnd");
  function _n(d) {
    return e.events.on("scroll", d);
  }
  o(_n, "onScroll");
  function lt(d) {
    return e.events.on("hide", d);
  }
  o(lt, "onHide");
  function De(d) {
    return e.events.on("show", d);
  }
  o(De, "onShow");
  let kt = xe((d) => e.events.on("gamepadButtonPress", (T) => d(T)), (d, T) => e.events.on("gamepadButtonPress", (G) => He(d, G) && T(G))), Hn = xe((d) => e.events.on("gamepadButtonDown", (T) => d(T)), (d, T) => e.events.on("gamepadButtonDown", (G) => He(d, G) && T(G))), Nt = xe((d) => e.events.on("gamepadButtonRelease", (T) => d(T)), (d, T) => e.events.on("gamepadButtonRelease", (G) => He(d, G) && T(G)));
  function Kn(d, T) {
    return e.events.on("gamepadStick", (G, $) => G === d && T($));
  }
  o(Kn, "onGamepadStick");
  function qn(d) {
    e.events.on("gamepadConnect", d);
  }
  o(qn, "onGamepadConnect");
  function pe(d) {
    e.events.on("gamepadDisconnect", d);
  }
  o(pe, "onGamepadDisconnect");
  function gt(d) {
    return e.mergedGamepadState.stickState.get(d) || new B(0);
  }
  o(gt, "getGamepadStick");
  function mt() {
    return [...e.charInputted];
  }
  o(mt, "charInputted");
  function Me() {
    return [...e.gamepads];
  }
  o(Me, "getGamepads");
  let Be = xe((d) => e.events.on("buttonPress", (T) => d(T)), (d, T) => e.events.on("buttonPress", (G) => He(d, G) && T(G))), bt = xe((d) => e.events.on("buttonDown", (T) => d(T)), (d, T) => e.events.on("buttonDown", (G) => He(d, G) && T(G))), _t = xe((d) => e.events.on("buttonRelease", (T) => d(T)), (d, T) => e.events.on("buttonRelease", (G) => He(d, G) && T(G)));
  function zn() {
    e.events.trigger("input"), e.keyState.down.forEach((d) => e.events.trigger("keyDown", d)), e.mouseState.down.forEach((d) => e.events.trigger("mouseDown", d)), e.buttonState.down.forEach((d) => e.events.trigger("buttonDown", d)), Wn();
  }
  o(zn, "processInput");
  function yt() {
    e.keyState.update(), e.mouseState.update(), e.buttonState.update(), e.mergedGamepadState.buttonState.update(), e.mergedGamepadState.stickState.forEach((d, T) => {
      e.mergedGamepadState.stickState.set(T, new B(0));
    }), e.charInputted = [], e.isMouseMoved = false, e.gamepadStates.forEach((d) => {
      d.buttonState.update(), d.stickState.forEach((T, G) => {
        d.stickState.set(G, new B(0));
      });
    });
  }
  o(yt, "resetInput");
  function _e(d) {
    let T = { index: d.index, isPressed: o((G) => e.gamepadStates.get(d.index).buttonState.pressed.has(G), "isPressed"), isDown: o((G) => e.gamepadStates.get(d.index).buttonState.down.has(G), "isDown"), isReleased: o((G) => e.gamepadStates.get(d.index).buttonState.released.has(G), "isReleased"), getStick: o((G) => e.gamepadStates.get(d.index).stickState.get(G), "getStick") };
    return e.gamepads.push(T), e.gamepadStates.set(d.index, { buttonState: new Et(), stickState: /* @__PURE__ */ new Map([["left", new B(0)], ["right", new B(0)]]) }), T;
  }
  o(_e, "registerGamepad");
  function vt(d) {
    e.gamepads = e.gamepads.filter((T) => T.index !== d.index), e.gamepadStates.delete(d.index);
  }
  o(vt, "removeGamepad");
  function Wn() {
    for (let d of navigator.getGamepads()) d && !e.gamepadStates.has(d.index) && _e(d);
    for (let d of e.gamepads) {
      let T = navigator.getGamepads()[d.index], $ = (t.gamepads ?? {})[T.id] ?? xr[T.id] ?? xr.default, Ce = e.gamepadStates.get(d.index);
      for (let me = 0; me < T.buttons.length; me++) {
        let fe = $.buttons[me], rt = T.buttons[me], $e = ct(fe);
        rt.pressed ? (Ce.buttonState.down.has(fe) || (e.mergedGamepadState.buttonState.press(fe), Ce.buttonState.press(fe), e.buttonState.press($e), e.events.trigger("gamepadButtonPress", fe), e.events.trigger("buttonPress", $e)), e.events.trigger("gamepadButtonDown", fe), e.events.trigger("buttonDown", $e)) : Ce.buttonState.down.has(fe) && (e.mergedGamepadState.buttonState.release(fe), Ce.buttonState.release(fe), e.buttonState.release($e), e.events.trigger("gamepadButtonRelease", fe), e.events.trigger("buttonRelease", $e));
      }
      for (let me in $.sticks) {
        let fe = $.sticks[me], rt = new B(T.axes[fe.x], T.axes[fe.y]);
        Ce.stickState.set(me, rt), e.mergedGamepadState.stickState.set(me, rt), e.events.trigger("gamepadStick", me, rt);
      }
    }
  }
  o(Wn, "processGamepad");
  let Ee = {}, xt = {}, et = {}, Ht = t.pixelDensity || window.devicePixelRatio || 1;
  Ee.mousemove = (d) => {
    let T = new B(d.offsetX, d.offsetY), G = new B(d.movementX, d.movementY);
    if (H()) {
      let $ = e.canvas.width / Ht, Ce = e.canvas.height / Ht, me = window.innerWidth, fe = window.innerHeight, rt = me / fe, $e = $ / Ce;
      if (rt > $e) {
        let Ge = fe / Ce, Dt = (me - $ * Ge) / 2;
        T.x = st(d.offsetX - Dt, 0, $ * Ge, 0, $), T.y = st(d.offsetY, 0, Ce * Ge, 0, Ce);
      } else {
        let Ge = me / $, Dt = (fe - Ce * Ge) / 2;
        T.x = st(d.offsetX, 0, $ * Ge, 0, $), T.y = st(d.offsetY - Dt, 0, Ce * Ge, 0, Ce);
      }
    }
    e.events.onOnce("input", () => {
      e.isMouseMoved = true, e.mousePos = T, e.mouseDeltaPos = G, e.events.trigger("mouseMove");
    });
  };
  let hn = ["left", "middle", "right", "back", "forward"];
  Ee.mousedown = (d) => {
    e.events.onOnce("input", () => {
      let T = hn[d.button];
      if (!T) return;
      let G = Ye(T);
      e.mouseState.press(T), e.buttonState.press(G), e.events.trigger("mousePress", T), e.events.trigger("buttonPress", G);
    });
  }, Ee.mouseup = (d) => {
    e.events.onOnce("input", () => {
      let T = hn[d.button];
      if (!T) return;
      let G = Ye(T);
      e.mouseState.release(T), e.buttonState.release(G), e.events.trigger("mouseRelease", T), e.events.trigger("buttonRelease", G);
    });
  };
  let pn = /* @__PURE__ */ new Set([" ", "ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Tab"]), Ut = { ArrowLeft: "left", ArrowRight: "right", ArrowUp: "up", ArrowDown: "down", " ": "space" };
  Ee.keydown = (d) => {
    pn.has(d.key) && d.preventDefault(), e.events.onOnce("input", () => {
      let T = Ut[d.key] || d.key.toLowerCase();
      if (T.length === 1 ? (e.events.trigger("charInput", T), e.charInputted.push(T)) : T === "space" && (e.events.trigger("charInput", " "), e.charInputted.push(" ")), d.repeat) e.keyState.pressRepeat(T), e.events.trigger("keyPressRepeat", T);
      else {
        let G = Ne(T);
        e.keyState.press(T), e.buttonState.press(G), e.events.trigger("keyPressRepeat", T), e.events.trigger("keyPress", T), e.events.trigger("buttonPress", G);
      }
    });
  }, Ee.keyup = (d) => {
    e.events.onOnce("input", () => {
      let T = Ut[d.key] || d.key.toLowerCase(), G = Ne(T);
      e.keyState.release(T), e.buttonState.release(G), e.events.trigger("keyRelease", T), e.events.trigger("buttonRelease", G);
    });
  }, Ee.touchstart = (d) => {
    d.preventDefault(), e.events.onOnce("input", () => {
      let T = [...d.changedTouches], G = e.canvas.getBoundingClientRect();
      if (t.touchToMouse !== false) {
        e.mousePos = new B(T[0].clientX - G.x, T[0].clientY - G.y);
        let $ = Ye("left");
        e.mouseState.press("left"), e.buttonState.press($), e.events.trigger("mousePress", "left"), e.events.trigger("buttonPress", $);
      }
      T.forEach(($) => {
        e.events.trigger("touchStart", new B($.clientX - G.x, $.clientY - G.y), $);
      });
    });
  }, Ee.touchmove = (d) => {
    d.preventDefault(), e.events.onOnce("input", () => {
      let T = [...d.changedTouches], G = e.canvas.getBoundingClientRect();
      if (t.touchToMouse !== false) {
        let $ = e.mousePos;
        e.mousePos = new B(T[0].clientX - G.x, T[0].clientY - G.y), e.mouseDeltaPos = e.mousePos.sub($), e.events.trigger("mouseMove");
      }
      T.forEach(($) => {
        e.events.trigger("touchMove", new B($.clientX - G.x, $.clientY - G.y), $);
      });
    });
  }, Ee.touchend = (d) => {
    e.events.onOnce("input", () => {
      let T = [...d.changedTouches], G = e.canvas.getBoundingClientRect();
      if (t.touchToMouse !== false) {
        e.mousePos = new B(T[0].clientX - G.x, T[0].clientY - G.y), e.mouseDeltaPos = new B(0, 0);
        let $ = Ye("left");
        e.buttonState.release($), e.mouseState.release("left"), e.events.trigger("mouseRelease", "left"), e.events.trigger("buttonRelease", $);
      }
      T.forEach(($) => {
        e.events.trigger("touchEnd", new B($.clientX - G.x, $.clientY - G.y), $);
      });
    });
  }, Ee.touchcancel = (d) => {
    e.events.onOnce("input", () => {
      let T = [...d.changedTouches], G = e.canvas.getBoundingClientRect();
      t.touchToMouse !== false && (e.mousePos = new B(T[0].clientX - G.x, T[0].clientY - G.y), e.mouseState.release("left"), e.events.trigger("mouseRelease", "left")), T.forEach(($) => {
        e.events.trigger("touchEnd", new B($.clientX - G.x, $.clientY - G.y), $);
      });
    });
  }, Ee.wheel = (d) => {
    d.preventDefault(), e.events.onOnce("input", () => {
      e.events.trigger("scroll", new B(d.deltaX, d.deltaY));
    });
  }, Ee.contextmenu = (d) => d.preventDefault(), xt.visibilitychange = () => {
    document.visibilityState === "visible" ? (e.skipTime = true, e.isHidden = false, e.events.trigger("show")) : (e.isHidden = true, e.events.trigger("hide"));
  }, et.gamepadconnected = (d) => {
    let T = _e(d.gamepad);
    e.events.onOnce("input", () => {
      e.events.trigger("gamepadConnect", T);
    });
  }, et.gamepaddisconnected = (d) => {
    let T = Me().filter((G) => G.index === d.gamepad.index)[0];
    vt(d.gamepad), e.events.onOnce("input", () => {
      e.events.trigger("gamepadDisconnect", T);
    });
  };
  for (let d in Ee) e.canvas.addEventListener(d, Ee[d]);
  for (let d in xt) document.addEventListener(d, xt[d]);
  for (let d in et) window.addEventListener(d, et[d]);
  let Kt = new ResizeObserver((d) => {
    for (let T of d) if (T.target === e.canvas) {
      if (e.lastWidth === e.canvas.offsetWidth && e.lastHeight === e.canvas.offsetHeight) return;
      e.lastWidth = e.canvas.offsetWidth, e.lastHeight = e.canvas.offsetHeight, e.events.onOnce("input", () => {
        e.events.trigger("resize");
      });
    }
  });
  return Kt.observe(e.canvas), { dt: n, time: a, run: N, canvas: e.canvas, fps: c, numFrames: h, quit: Q, isHidden: s, setFullscreen: j, isFullscreen: H, setCursor: p, screenshot: b, getGamepads: Me, getCursor: l, setCursorLocked: M, isCursorLocked: y, isTouchscreen: J, mousePos: A, mouseDeltaPos: te, isKeyDown: be, isKeyPressed: le, isKeyPressedRepeat: we, isKeyReleased: Oe, isMouseDown: se, isMousePressed: W, isMouseReleased: ne, isMouseMoved: ae, isGamepadButtonPressed: ye, isGamepadButtonDown: Ke, isGamepadButtonReleased: qe, getGamepadStick: gt, isButtonPressed: ze, isButtonDown: We, isButtonReleased: ft, setButton: Ue, getButton: Ae, charInputted: mt, onResize: Vt, onKeyDown: un, onKeyPress: Fn, onKeyPressRepeat: cn, onKeyRelease: In, onMouseDown: Ln, onMousePress: ln, onMouseRelease: jn, onMouseMove: kn, onCharInput: mn, onTouchStart: dn, onTouchMove: Nn, onTouchEnd: jt, onScroll: _n, onHide: lt, onShow: De, onGamepadButtonDown: Hn, onGamepadButtonPress: kt, onGamepadButtonRelease: Nt, onGamepadStick: Kn, onGamepadConnect: qn, onGamepadDisconnect: pe, onButtonPress: Be, onButtonDown: bt, onButtonRelease: _t, events: e.events };
}, "default");
var _a21;
var Xe = (_a21 = class {
  constructor(e, n, s, a = {}) {
    __publicField(this, "ctx");
    __publicField(this, "src", null);
    __publicField(this, "glTex");
    __publicField(this, "width");
    __publicField(this, "height");
    this.ctx = e;
    let c = e.gl;
    this.glTex = e.gl.createTexture(), e.onDestroy(() => this.free()), this.width = n, this.height = s;
    let h = { linear: c.LINEAR, nearest: c.NEAREST }[a.filter ?? e.opts.texFilter] ?? c.NEAREST, b = { repeat: c.REPEAT, clampToEadge: c.CLAMP_TO_EDGE }[a.wrap] ?? c.CLAMP_TO_EDGE;
    this.bind(), n && s && c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, n, s, 0, c.RGBA, c.UNSIGNED_BYTE, null), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, h), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, h), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, b), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, b), this.unbind();
  }
  static fromImage(e, n, s = {}) {
    let a = new _a21(e, n.width, n.height, s);
    return a.update(n), a.src = n, a;
  }
  update(e, n = 0, s = 0) {
    let a = this.ctx.gl;
    this.bind(), a.texSubImage2D(a.TEXTURE_2D, 0, n, s, a.RGBA, a.UNSIGNED_BYTE, e), this.unbind();
  }
  bind() {
    this.ctx.pushTexture2D(this.glTex);
  }
  unbind() {
    this.ctx.popTexture2D();
  }
  free() {
    this.ctx.gl.deleteTexture(this.glTex);
  }
}, o(_a21, "Texture"), _a21);
var _a22;
var At = (_a22 = class {
  constructor(e, n, s, a = {}) {
    __publicField(this, "ctx");
    __publicField(this, "tex");
    __publicField(this, "glFramebuffer");
    __publicField(this, "glRenderbuffer");
    this.ctx = e;
    let c = e.gl;
    e.onDestroy(() => this.free()), this.tex = new Xe(e, n, s, a), this.glFramebuffer = c.createFramebuffer(), this.glRenderbuffer = c.createRenderbuffer(), this.bind(), c.renderbufferStorage(c.RENDERBUFFER, c.DEPTH_STENCIL, n, s), c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, this.tex.glTex, 0), c.framebufferRenderbuffer(c.FRAMEBUFFER, c.DEPTH_STENCIL_ATTACHMENT, c.RENDERBUFFER, this.glRenderbuffer), this.unbind();
  }
  get width() {
    return this.tex.width;
  }
  get height() {
    return this.tex.height;
  }
  toImageData() {
    let e = this.ctx.gl, n = new Uint8ClampedArray(this.width * this.height * 4);
    this.bind(), e.readPixels(0, 0, this.width, this.height, e.RGBA, e.UNSIGNED_BYTE, n), this.unbind();
    let s = this.width * 4, a = new Uint8Array(s);
    for (let c = 0; c < (this.height / 2 | 0); c++) {
      let h = c * s, b = (this.height - c - 1) * s;
      a.set(n.subarray(h, h + s)), n.copyWithin(h, b, b + s), n.set(a, b);
    }
    return new ImageData(n, this.width, this.height);
  }
  toDataURL() {
    let e = document.createElement("canvas"), n = e.getContext("2d");
    return e.width = this.width, e.height = this.height, n.putImageData(this.toImageData(), 0, 0), e.toDataURL();
  }
  clear() {
    let e = this.ctx.gl;
    e.clear(e.COLOR_BUFFER_BIT);
  }
  draw(e) {
    this.bind(), e(), this.unbind();
  }
  bind() {
    this.ctx.pushFramebuffer(this.glFramebuffer), this.ctx.pushRenderbuffer(this.glRenderbuffer), this.ctx.pushViewport({ x: 0, y: 0, w: this.width, h: this.height });
  }
  unbind() {
    this.ctx.popFramebuffer(), this.ctx.popRenderbuffer(), this.ctx.popViewport();
  }
  free() {
    let e = this.ctx.gl;
    e.deleteFramebuffer(this.glFramebuffer), e.deleteRenderbuffer(this.glRenderbuffer), this.tex.free();
  }
}, o(_a22, "FrameBuffer"), _a22);
var _a23;
var En = (_a23 = class {
  constructor(e, n, s, a) {
    __publicField(this, "ctx");
    __publicField(this, "glProgram");
    this.ctx = e, e.onDestroy(() => this.free());
    let c = e.gl, h = c.createShader(c.VERTEX_SHADER), b = c.createShader(c.FRAGMENT_SHADER);
    c.shaderSource(h, n), c.shaderSource(b, s), c.compileShader(h), c.compileShader(b);
    let p = c.createProgram();
    if (this.glProgram = p, c.attachShader(p, h), c.attachShader(p, b), a.forEach((l, M) => c.bindAttribLocation(p, M, l)), c.linkProgram(p), !c.getProgramParameter(p, c.LINK_STATUS)) {
      let l = c.getShaderInfoLog(h);
      if (l) throw new Error("VERTEX SHADER " + l);
      let M = c.getShaderInfoLog(b);
      if (M) throw new Error("FRAGMENT SHADER " + M);
    }
    c.deleteShader(h), c.deleteShader(b);
  }
  bind() {
    this.ctx.pushProgram(this.glProgram);
  }
  unbind() {
    this.ctx.popProgram();
  }
  send(e) {
    let n = this.ctx.gl;
    for (let s in e) {
      let a = e[s], c = n.getUniformLocation(this.glProgram, s);
      if (typeof a == "number") n.uniform1f(c, a);
      else if (a instanceof Le) n.uniformMatrix4fv(c, false, new Float32Array(a.m));
      else if (a instanceof oe) n.uniform3f(c, a.r, a.g, a.b);
      else if (a instanceof B) n.uniform2f(c, a.x, a.y);
      else if (Array.isArray(a)) {
        let h = a[0];
        typeof h == "number" ? n.uniform1fv(c, a) : h instanceof B ? n.uniform2fv(c, a.map((b) => [b.x, b.y]).flat()) : h instanceof oe && n.uniform3fv(c, a.map((b) => [b.r, b.g, b.b]).flat());
      } else throw new Error("Unsupported uniform data type");
    }
  }
  free() {
    this.ctx.gl.deleteProgram(this.glProgram);
  }
}, o(_a23, "Shader"), _a23);
var _a24;
var On = (_a24 = class {
  constructor(e, n, s, a) {
    __publicField(this, "ctx");
    __publicField(this, "glVBuf");
    __publicField(this, "glIBuf");
    __publicField(this, "vqueue", []);
    __publicField(this, "iqueue", []);
    __publicField(this, "stride");
    __publicField(this, "maxVertices");
    __publicField(this, "maxIndices");
    __publicField(this, "vertexFormat");
    __publicField(this, "numDraws", 0);
    __publicField(this, "curPrimitive", null);
    __publicField(this, "curTex", null);
    __publicField(this, "curShader", null);
    __publicField(this, "curUniform", {});
    let c = e.gl;
    this.vertexFormat = n, this.ctx = e, this.stride = n.reduce((h, b) => h + b.size, 0), this.maxVertices = s, this.maxIndices = a, this.glVBuf = c.createBuffer(), e.pushArrayBuffer(this.glVBuf), c.bufferData(c.ARRAY_BUFFER, s * 4, c.DYNAMIC_DRAW), e.popArrayBuffer(), this.glIBuf = c.createBuffer(), e.pushElementArrayBuffer(this.glIBuf), c.bufferData(c.ELEMENT_ARRAY_BUFFER, a * 4, c.DYNAMIC_DRAW), e.popElementArrayBuffer();
  }
  push(e, n, s, a, c = null, h = {}) {
    (e !== this.curPrimitive || c !== this.curTex || a !== this.curShader || !Tn(this.curUniform, h) || this.vqueue.length + n.length * this.stride > this.maxVertices || this.iqueue.length + s.length > this.maxIndices) && this.flush();
    let b = this.vqueue.length / this.stride;
    for (let p of n) this.vqueue.push(p);
    for (let p of s) this.iqueue.push(p + b);
    this.curPrimitive = e, this.curShader = a, this.curTex = c, this.curUniform = h;
  }
  flush() {
    var _a29, _b;
    if (!this.curPrimitive || !this.curShader || this.vqueue.length === 0 || this.iqueue.length === 0) return;
    let e = this.ctx.gl;
    this.ctx.pushArrayBuffer(this.glVBuf), e.bufferSubData(e.ARRAY_BUFFER, 0, new Float32Array(this.vqueue)), this.ctx.pushElementArrayBuffer(this.glIBuf), e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, new Uint16Array(this.iqueue)), this.ctx.setVertexFormat(this.vertexFormat), this.curShader.bind(), this.curShader.send(this.curUniform), (_a29 = this.curTex) == null ? void 0 : _a29.bind(), e.drawElements(this.curPrimitive, this.iqueue.length, e.UNSIGNED_SHORT, 0), (_b = this.curTex) == null ? void 0 : _b.unbind(), this.curShader.unbind(), this.ctx.popArrayBuffer(), this.ctx.popElementArrayBuffer(), this.vqueue = [], this.iqueue = [], this.numDraws++;
  }
  free() {
    let e = this.ctx.gl;
    e.deleteBuffer(this.glVBuf), e.deleteBuffer(this.glIBuf);
  }
}, o(_a24, "BatchRenderer"), _a24);
function Ot(t) {
  let e = [], n = o((c) => {
    e.push(c), t(c);
  }, "push"), s = o(() => {
    e.pop(), t(a() ?? null);
  }, "pop"), a = o(() => e[e.length - 1], "cur");
  return [n, s, a];
}
o(Ot, "genStack");
function Tr(t, e = {}) {
  let n = [];
  function s(W) {
    n.push(W);
  }
  o(s, "onDestroy");
  function a() {
    n.forEach((W) => W()), t.getExtension("WEBGL_lose_context").loseContext();
  }
  o(a, "destroy");
  let c = null;
  function h(W) {
    if (Tn(W, c)) return;
    c = W;
    let se = W.reduce((ne, ae) => ne + ae.size, 0);
    W.reduce((ne, ae, le) => (t.vertexAttribPointer(le, ae.size, t.FLOAT, false, se * 4, ne), t.enableVertexAttribArray(le), ne + ae.size * 4), 0);
  }
  o(h, "setVertexFormat");
  let [b, p] = Ot((W) => t.bindTexture(t.TEXTURE_2D, W)), [l, M] = Ot((W) => t.bindBuffer(t.ARRAY_BUFFER, W)), [y, P] = Ot((W) => t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, W)), [v, j] = Ot((W) => t.bindFramebuffer(t.FRAMEBUFFER, W)), [H, Q] = Ot((W) => t.bindRenderbuffer(t.RENDERBUFFER, W)), [N, J] = Ot(({ x: W, y: se, w: ne, h: ae }) => {
    t.viewport(W, se, ne, ae);
  }), [A, te] = Ot((W) => t.useProgram(W));
  return N({ x: 0, y: 0, w: t.drawingBufferWidth, h: t.drawingBufferHeight }), { gl: t, opts: e, onDestroy: s, destroy: a, pushTexture2D: b, popTexture2D: p, pushArrayBuffer: l, popArrayBuffer: M, pushElementArrayBuffer: y, popElementArrayBuffer: P, pushFramebuffer: v, popFramebuffer: j, pushRenderbuffer: H, popRenderbuffer: Q, pushViewport: N, popViewport: J, pushProgram: A, popProgram: te, setVertexFormat: h };
}
o(Tr, "initGfx");
var _a25;
var Ve = (_a25 = class {
  constructor(e) {
    __publicField(this, "loaded", false);
    __publicField(this, "data", null);
    __publicField(this, "error", null);
    __publicField(this, "onLoadEvents", new Se());
    __publicField(this, "onErrorEvents", new Se());
    __publicField(this, "onFinishEvents", new Se());
    e.then((n) => {
      this.loaded = true, this.data = n, this.onLoadEvents.trigger(n);
    }).catch((n) => {
      if (this.error = n, this.onErrorEvents.numListeners() > 0) this.onErrorEvents.trigger(n);
      else throw n;
    }).finally(() => {
      this.onFinishEvents.trigger(), this.loaded = true;
    });
  }
  static loaded(e) {
    let n = new _a25(Promise.resolve(e));
    return n.data = e, n.loaded = true, n;
  }
  onLoad(e) {
    return this.loaded && this.data ? e(this.data) : this.onLoadEvents.add(e), this;
  }
  onError(e) {
    return this.loaded && this.error ? e(this.error) : this.onErrorEvents.add(e), this;
  }
  onFinish(e) {
    return this.loaded ? e() : this.onFinishEvents.add(e), this;
  }
  then(e) {
    return this.onLoad(e);
  }
  catch(e) {
    return this.onError(e);
  }
  finally(e) {
    return this.onFinish(e);
  }
}, o(_a25, "Asset"), _a25);
var _a26;
var ut = (_a26 = class {
  constructor() {
    __publicField(this, "assets", /* @__PURE__ */ new Map());
    __publicField(this, "lastUID", 0);
  }
  add(e, n) {
    let s = e ?? this.lastUID++ + "", a = new Ve(n);
    return this.assets.set(s, a), a;
  }
  addLoaded(e, n) {
    let s = e ?? this.lastUID++ + "", a = Ve.loaded(n);
    return this.assets.set(s, a), a;
  }
  get(e) {
    return this.assets.get(e);
  }
  progress() {
    if (this.assets.size === 0) return 1;
    let e = 0;
    return this.assets.forEach((n) => {
      n.loaded && e++;
    }), e / this.assets.size;
  }
}, o(_a26, "AssetBucket"), _a26);
function Sr(t) {
  return fetch(t).then((e) => {
    if (!e.ok) throw new Error(`Failed to fetch "${t}"`);
    return e;
  });
}
o(Sr, "fetchURL");
function Jt(t) {
  return Sr(t).then((e) => e.json());
}
o(Jt, "fetchJSON");
function Mo(t) {
  return Sr(t).then((e) => e.text());
}
o(Mo, "fetchText");
function Bo(t) {
  return Sr(t).then((e) => e.arrayBuffer());
}
o(Bo, "fetchArrayBuffer");
function Zt(t) {
  let e = new Image();
  return e.crossOrigin = "anonymous", e.src = t, new Promise((n, s) => {
    e.onload = () => n(e), e.onerror = () => s(new Error(`Failed to load image from "${t}"`));
  });
}
o(Zt, "loadImg");
var Er = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
var It = "topleft";
var Go = "monospace";
var en = "monospace";
var tn = "linear";
var An = [{ name: "a_pos", size: 2 }, { name: "a_uv", size: 2 }, { name: "a_color", size: 4 }];
var ma = An.reduce((t, e) => t + e.size, 0);
var Fo = 2048;
var Io = Fo * 4 * ma;
var Lo = Fo * 6;
var jo = `
attribute vec2 a_pos;
attribute vec2 a_uv;
attribute vec4 a_color;

varying vec2 v_pos;
varying vec2 v_uv;
varying vec4 v_color;

vec4 def_vert() {
	return vec4(a_pos, 0.0, 1.0);
}

{{user}}

void main() {
	vec4 pos = vert(a_pos, a_uv, a_color);
	v_pos = a_pos;
	v_uv = a_uv;
	v_color = a_color;
	gl_Position = pos;
}
`;
var ko = `
precision mediump float;

varying vec2 v_pos;
varying vec2 v_uv;
varying vec4 v_color;

uniform sampler2D u_tex;

vec4 def_frag() {
	return v_color * texture2D(u_tex, v_uv);
}

{{user}}

void main() {
	gl_FragColor = frag(v_pos, v_uv, v_color, u_tex);
	if (gl_FragColor.a == 0.0) {
		discard;
	}
}
`;
var Rn = `
vec4 vert(vec2 pos, vec2 uv, vec4 color) {
	return def_vert();
}
`;
var Pn = `
vec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {
	return def_frag();
}
`;
var No = /* @__PURE__ */ new Set(["id", "require"]);
var _o = /* @__PURE__ */ new Set(["add", "update", "draw", "destroy", "inspect", "drawInspect"]);
var Or = /\[(?<style>\w+)\](?<text>.*?)\[\/\k<style>\]/g;
var Ho = 200;
var Ko = 640;
var qo = 65536;
var Vn = 2.5949095;
var zo = 1.70158 + 1;
var Wo = 2 * Math.PI / 3;
var Xo = 2 * Math.PI / 4.5;
var Un = { linear: o((t) => t, "linear"), easeInSine: o((t) => 1 - Math.cos(t * Math.PI / 2), "easeInSine"), easeOutSine: o((t) => Math.sin(t * Math.PI / 2), "easeOutSine"), easeInOutSine: o((t) => -(Math.cos(Math.PI * t) - 1) / 2, "easeInOutSine"), easeInQuad: o((t) => t * t, "easeInQuad"), easeOutQuad: o((t) => 1 - (1 - t) * (1 - t), "easeOutQuad"), easeInOutQuad: o((t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2, "easeInOutQuad"), easeInCubic: o((t) => t * t * t, "easeInCubic"), easeOutCubic: o((t) => 1 - Math.pow(1 - t, 3), "easeOutCubic"), easeInOutCubic: o((t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2, "easeInOutCubic"), easeInQuart: o((t) => t * t * t * t, "easeInQuart"), easeOutQuart: o((t) => 1 - Math.pow(1 - t, 4), "easeOutQuart"), easeInOutQuart: o((t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2, "easeInOutQuart"), easeInQuint: o((t) => t * t * t * t * t, "easeInQuint"), easeOutQuint: o((t) => 1 - Math.pow(1 - t, 5), "easeOutQuint"), easeInOutQuint: o((t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2, "easeInOutQuint"), easeInExpo: o((t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10), "easeInExpo"), easeOutExpo: o((t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t), "easeOutExpo"), easeInOutExpo: o((t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2, "easeInOutExpo"), easeInCirc: o((t) => 1 - Math.sqrt(1 - Math.pow(t, 2)), "easeInCirc"), easeOutCirc: o((t) => Math.sqrt(1 - Math.pow(t - 1, 2)), "easeOutCirc"), easeInOutCirc: o((t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2, "easeInOutCirc"), easeInBack: o((t) => zo * t * t * t - 1.70158 * t * t, "easeInBack"), easeOutBack: o((t) => 1 + zo * Math.pow(t - 1, 3) + 1.70158 * Math.pow(t - 1, 2), "easeOutBack"), easeInOutBack: o((t) => t < 0.5 ? Math.pow(2 * t, 2) * ((Vn + 1) * 2 * t - Vn) / 2 : (Math.pow(2 * t - 2, 2) * ((Vn + 1) * (t * 2 - 2) + Vn) + 2) / 2, "easeInOutBack"), easeInElastic: o((t) => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * Wo), "easeInElastic"), easeOutElastic: o((t) => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * Wo) + 1, "easeOutElastic"), easeInOutElastic: o((t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * Xo)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * Xo) / 2 + 1, "easeInOutElastic"), easeInBounce: o((t) => 1 - Un.easeOutBounce(1 - t), "easeInBounce"), easeOutBounce: o((t) => t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375, "easeOutBounce"), easeInOutBounce: o((t) => t < 0.5 ? (1 - Un.easeOutBounce(1 - 2 * t)) / 2 : (1 + Un.easeOutBounce(2 * t - 1)) / 2, "easeInOutBounce") };
var Lt = Un;
var _a27;
var nn = (_a27 = class {
  constructor(e, n, s) {
    __publicField(this, "textures", []);
    __publicField(this, "bigTextures", []);
    __publicField(this, "canvas");
    __publicField(this, "c2d");
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "curHeight", 0);
    __publicField(this, "gfx");
    this.gfx = e, this.canvas = document.createElement("canvas"), this.canvas.width = n, this.canvas.height = s, this.textures = [Xe.fromImage(e, this.canvas)], this.bigTextures = [], this.c2d = this.canvas.getContext("2d");
  }
  add(e) {
    if (e.width > this.canvas.width || e.height > this.canvas.height) {
      let a = Xe.fromImage(this.gfx, e);
      return this.bigTextures.push(a), [a, new he(0, 0, 1, 1)];
    }
    this.x + e.width > this.canvas.width && (this.x = 0, this.y += this.curHeight, this.curHeight = 0), this.y + e.height > this.canvas.height && (this.c2d.clearRect(0, 0, this.canvas.width, this.canvas.height), this.textures.push(Xe.fromImage(this.gfx, this.canvas)), this.x = 0, this.y = 0, this.curHeight = 0);
    let n = this.textures[this.textures.length - 1], s = new B(this.x, this.y);
    return this.x += e.width, e.height > this.curHeight && (this.curHeight = e.height), e instanceof ImageData ? this.c2d.putImageData(e, s.x, s.y) : this.c2d.drawImage(e, s.x, s.y), n.update(this.canvas), [n, new he(s.x / this.canvas.width, s.y / this.canvas.height, e.width / this.canvas.width, e.height / this.canvas.height)];
  }
  free() {
    for (let e of this.textures) e.free();
    for (let e of this.bigTextures) e.free();
  }
}, o(_a27, "TexPacker"), _a27);
var _a28;
var Rt = (_a28 = class {
  constructor(e, n = {}) {
    __publicField(this, "fontface");
    __publicField(this, "filter", tn);
    __publicField(this, "outline", null);
    __publicField(this, "size", 64);
    if (this.fontface = e, this.filter = n.filter ?? tn, this.size = n.size ?? 64, this.size > 256) throw new Error(`Max font size: ${256}`);
    n.outline && (this.outline = { width: 1, color: ie(0, 0, 0) }, typeof n.outline == "number" ? this.outline.width = n.outline : typeof n.outline == "object" && (n.outline.width && (this.outline.width = n.outline.width), n.outline.color && (this.outline.color = n.outline.color)));
  }
}, o(_a28, "FontData"), _a28);
function Yo(t, e = {}) {
  let n = re(this), { getRenderProps: s } = n._k;
  return { id: "circle", radius: t, draw() {
    n.drawCircle(Object.assign(s(this), { radius: this.radius, fill: e.fill }));
  }, renderArea() {
    return new ce(new B(this.anchor ? 0 : -this.radius), this.radius * 2, this.radius * 2);
  }, inspect() {
    return `${Math.ceil(this.radius)}`;
  } };
}
o(Yo, "circle");
function Ar(...t) {
  return { id: "color", color: ie(...t), inspect() {
    return this.color.toString();
  } };
}
o(Ar, "color");
function $o(t) {
  return { add() {
    this.canvas = t;
  } };
}
o($o, "drawon");
function Qo(t = 1) {
  let e = re(this), n, s = 0, a = false;
  return { require: ["opacity"], add() {
    n = this.opacity, this.opacity = 0;
  }, update() {
    a || (s += e.dt(), this.opacity = e.map(s, 0, t, 0, n), s >= t && (this.opacity = n, a = true));
  } };
}
o(Qo, "fadeIn");
function Jo(t = "intersect") {
  return { id: "mask", mask: t };
}
o(Jo, "mask");
function Rr(t) {
  let e = re(this), { toFixed: n } = e._k;
  return { id: "opacity", opacity: t ?? 1, inspect() {
    return `${n(this.opacity, 1)}`;
  }, fadeIn(s = 1, a = e.easings.linear) {
    return e.tween(0, this.opacity, s, (c) => this.opacity = c, a);
  }, fadeOut(s = 1, a = e.easings.linear) {
    return e.tween(this.opacity, 0, s, (c) => this.opacity = c, a);
  } };
}
o(Rr, "opacity");
function Zo(t = 1, e = ie(0, 0, 0), n = 1, s = "miter", a = 10, c = "butt") {
  return { id: "outline", outline: { width: t, color: e, opacity: n, join: s, miterLimit: a, cap: c }, inspect() {
    return `${this.outline.width}, ${this.outline.color}`;
  } };
}
o(Zo, "outline");
function es(t, e = {}) {
  let n = re(this), { getRenderProps: s } = n._k;
  if (t.length < 3) throw new Error(`Polygon's need more than two points, ${t.length} points provided`);
  return { id: "polygon", pts: t, colors: e.colors, uv: e.uv, tex: e.tex, radius: e.radius, draw() {
    n.drawPolygon(Object.assign(s(this), { pts: this.pts, colors: this.colors, uv: this.uv, tex: this.tex, radius: this.radius, fill: e.fill, triangulate: e.triangulate }));
  }, renderArea() {
    return new Pe(this.pts);
  }, inspect() {
    return this.pts.map((a) => `[${a.x},${a.y}]`).join(",");
  } };
}
o(es, "polygon");
function ts(t, e, n) {
  let s = re(this), a;
  return s.get("area").forEach((h) => {
    if (n && n.some((l) => h.is(l))) return;
    let p = h.worldArea().raycast(t, e);
    p && (a ? p.fraction < a.fraction && (a = p, a.object = h) : (a = p, a.object = h));
  }), a;
}
o(ts, "raycast");
function Pr(t, e, n = {}) {
  let s = re(this), { getRenderProps: a } = s._k;
  return { id: "rect", width: t, height: e, radius: n.radius || 0, draw() {
    s.drawRect(Object.assign(a(this), { width: this.width, height: this.height, radius: this.radius, fill: n.fill }));
  }, renderArea() {
    return new ce(E(0), this.width, this.height);
  }, inspect() {
    return `${Math.ceil(this.width)}, ${Math.ceil(this.height)}`;
  } };
}
o(Pr, "rect");
function ns(t, e) {
  return { id: "shader", shader: t, ...typeof e == "function" ? { uniform: e(), update() {
    this.uniform = e();
  } } : { uniform: e }, inspect() {
    return `shader: ${t}`;
  } };
}
o(ns, "shader");
function Dn(t, e = {}) {
  let n = re(this), { drawTexture: s, getRenderProps: a, resolveSprite: c } = n._k, h = null, b = null, p = null, l = new Se();
  if (!t) throw new Error("Please pass the resource name or data to sprite()");
  let M = o((y, P, v, j) => {
    let H = E(1, 1);
    return v && j ? (H.x = v / (y.width * P.w), H.y = j / (y.height * P.h)) : v ? (H.x = v / (y.width * P.w), H.y = H.x) : j && (H.y = j / (y.height * P.h), H.x = H.y), H;
  }, "calcTexScale");
  return { id: "sprite", width: 0, height: 0, frame: e.frame || 0, quad: e.quad || new he(0, 0, 1, 1), animSpeed: e.animSpeed ?? 1, flipX: e.flipX ?? false, flipY: e.flipY ?? false, get sprite() {
    return t.toString();
  }, draw() {
    if (!h) return;
    let y = h.frames[this.frame ?? 0];
    if (!y) throw new Error(`Frame not found: ${this.frame ?? 0}`);
    if (h.slice9) {
      let { left: P, right: v, top: j, bottom: H } = h.slice9, Q = h.tex.width * y.w, N = h.tex.height * y.h, J = this.width - P - v, A = this.height - j - H, te = P / Q, W = v / Q, se = 1 - te - W, ne = j / N, ae = H / N, le = 1 - ne - ae, we = [ge(0, 0, te, ne), ge(te, 0, se, ne), ge(te + se, 0, W, ne), ge(0, ne, te, le), ge(te, ne, se, le), ge(te + se, ne, W, le), ge(0, ne + le, te, ae), ge(te, ne + le, se, ae), ge(te + se, ne + le, W, ae), ge(0, 0, P, j), ge(P, 0, J, j), ge(P + J, 0, v, j), ge(0, j, P, A), ge(P, j, J, A), ge(P + J, j, v, A), ge(0, j + A, P, H), ge(P, j + A, J, H), ge(P + J, j + A, v, H)];
      for (let be = 0; be < 9; be++) {
        let Oe = we[be], ye = we[be + 9];
        s(Object.assign(a(this), { pos: ye.pos(), tex: h.tex, quad: y.scale(Oe), flipX: this.flipX, flipY: this.flipY, tiled: e.tiled, width: ye.w, height: ye.h }));
      }
    } else s(Object.assign(a(this), { tex: h.tex, quad: y.scale(this.quad ?? new he(0, 0, 1, 1)), flipX: this.flipX, flipY: this.flipY, tiled: e.tiled, width: this.width, height: this.height }));
  }, add() {
    let y = o((v) => {
      let j = v.frames[0].clone();
      e.quad && (j = j.scale(e.quad));
      let H = M(v.tex, j, e.width, e.height);
      this.width = v.tex.width * j.w * H.x, this.height = v.tex.height * j.h * H.y, e.anim && this.play(e.anim), h = v, l.trigger(h);
    }, "setSpriteData"), P = c(t);
    P ? P.onLoad(y) : n.onLoad(() => y(c(t).data));
  }, update() {
    if (!b) return;
    let y = h.anims[b.name];
    if (typeof y == "number") {
      this.frame = y;
      return;
    }
    if (y.speed === 0) throw new Error("Sprite anim speed cannot be 0");
    b.timer += n.dt() * this.animSpeed, b.timer >= 1 / b.speed && (b.timer = 0, this.frame += p, (this.frame < Math.min(y.from, y.to) || this.frame > Math.max(y.from, y.to)) && (b.loop ? b.pingpong ? (this.frame -= p, p *= -1, this.frame += p) : this.frame = y.from : b.pingpong ? p === Math.sign(y.to - y.from) ? (this.frame = y.to, p *= -1, this.frame += p) : (this.frame = y.from, b.onEnd(), this.stop()) : (this.frame = y.to, b.onEnd(), this.stop())));
  }, play(y, P = {}) {
    if (!h) {
      l.add(() => this.play(y, P));
      return;
    }
    let v = h.anims[y];
    if (v === void 0) throw new Error(`Anim not found: ${y}`);
    b && this.stop(), b = typeof v == "number" ? { name: y, timer: 0, loop: false, pingpong: false, speed: 0, onEnd: o(() => {
    }, "onEnd") } : { name: y, timer: 0, loop: P.loop ?? v.loop ?? false, pingpong: P.pingpong ?? v.pingpong ?? false, speed: P.speed ?? v.speed ?? 10, onEnd: P.onEnd ?? (() => {
    }) }, p = typeof v == "number" ? null : v.from < v.to ? 1 : -1, this.frame = typeof v == "number" ? v : v.from, this.trigger("animStart", y);
  }, stop() {
    if (!b) return;
    let y = b.name;
    b = null, this.trigger("animEnd", y);
  }, numFrames() {
    return (h == null ? void 0 : h.frames.length) ?? 0;
  }, getCurAnim() {
    return b;
  }, curAnim() {
    return b == null ? void 0 : b.name;
  }, onAnimEnd(y) {
    return this.on("animEnd", y);
  }, onAnimStart(y) {
    return this.on("animStart", y);
  }, renderArea() {
    return new n.Rect(E(0), this.width, this.height);
  }, inspect() {
    if (typeof t == "string") return `"${t}"`;
  } };
}
o(Dn, "sprite");
function rs(t, e = {}) {
  let n = re(this), { getRenderProps: s } = n._k;
  function a(h) {
    var _a29, _b;
    let b = n.formatText(Object.assign(s(h), { text: h.text + "", size: h.textSize, font: h.font, width: e.width && h.width, align: h.align, letterSpacing: h.letterSpacing, lineSpacing: h.lineSpacing, transform: h.textTransform, styles: h.textStyles }));
    return e.width || (h.width = b.width / (((_a29 = h.scale) == null ? void 0 : _a29.x) || 1)), h.height = b.height / (((_b = h.scale) == null ? void 0 : _b.y) || 1), b;
  }
  o(a, "update");
  let c = { id: "text", set text(h) {
    t = h, a(this);
  }, get text() {
    return t;
  }, textSize: e.size ?? 36, font: e.font, width: e.width ?? 0, height: 0, align: e.align, lineSpacing: e.lineSpacing, letterSpacing: e.letterSpacing, textTransform: e.transform, textStyles: e.styles, add() {
    n.onLoad(() => a(this));
  }, draw() {
    n.drawFormattedText(a(this));
  }, renderArea() {
    return new ce(E(0), this.width, this.height);
  } };
  return a(c), c;
}
o(rs, "text");
function os(t, e) {
  let n = re(this), { getRenderProps: s } = n._k;
  return { id: "rect", width: t, height: e, draw() {
    n.drawUVQuad(Object.assign(s(this), { width: this.width, height: this.height }));
  }, renderArea() {
    return new ce(E(0), this.width, this.height);
  }, inspect() {
    return `${Math.ceil(this.width)}, ${Math.ceil(this.height)}`;
  } };
}
o(os, "uvquad");
function ss(t = {}) {
  let e = null, n = null, s = null, a = null;
  return { id: "agent", require: ["pos", "tile"], agentSpeed: t.speed ?? 100, allowDiagonals: t.allowDiagonals ?? true, getDistanceToTarget() {
    return e ? this.pos.dist(e) : 0;
  }, getNextLocation() {
    return n && s ? n[s] : null;
  }, getPath() {
    return n ? n.slice() : null;
  }, getTarget() {
    return e;
  }, isNavigationFinished() {
    return n ? s === null : true;
  }, isTargetReachable() {
    return n !== null;
  }, isTargetReached() {
    return e ? this.pos.eq(e) : true;
  }, setTarget(c) {
    e = c, n = this.getLevel().getPath(this.pos, e, { allowDiagonals: this.allowDiagonals }), s = n ? 0 : null, n ? (a || (a = this.getLevel().onNavigationMapChanged(() => {
      n && s !== null && (n = this.getLevel().getPath(this.pos, e, { allowDiagonals: this.allowDiagonals }), s = n ? 0 : null, n ? this.trigger("navigation-next", this, n[s]) : this.trigger("navigation-ended", this));
    }), this.onDestroy(() => a.cancel())), this.trigger("navigation-started", this), this.trigger("navigation-next", this, n[s])) : this.trigger("navigation-ended", this);
  }, update() {
    if (n && s !== null) {
      if (this.pos.sdist(n[s]) < 2) if (s === n.length - 1) {
        this.pos = e.clone(), s = null, this.trigger("navigation-ended", this), this.trigger("target-reached", this);
        return;
      } else s++, this.trigger("navigation-next", this, n[s]);
      this.moveTo(n[s], this.agentSpeed);
    }
  }, onNavigationStarted(c) {
    return this.on("navigation-started", c);
  }, onNavigationNext(c) {
    return this.on("navigation-next", c);
  }, onNavigationEnded(c) {
    return this.on("navigation-ended", c);
  }, onTargetReached(c) {
    return this.on("target-reached", c);
  }, inspect() {
    return JSON.stringify({ target: JSON.stringify(e), path: JSON.stringify(n) });
  } };
}
o(ss, "agent");
function Vr(t = {}) {
  let e = E(0), n = t.isObstacle ?? false, s = t.cost ?? 0, a = t.edges ?? [], c = o(() => {
    let b = { left: 1, top: 2, right: 4, bottom: 8 };
    return a.map((p) => b[p] || 0).reduce((p, l) => p | l, 0);
  }, "getEdgeMask"), h = c();
  return { id: "tile", tilePosOffset: t.offset ?? E(0), set tilePos(b) {
    let p = this.getLevel();
    e = b.clone(), this.pos = E(this.tilePos.x * p.tileWidth(), this.tilePos.y * p.tileHeight()).add(this.tilePosOffset);
  }, get tilePos() {
    return e;
  }, set isObstacle(b) {
    n !== b && (n = b, this.getLevel().invalidateNavigationMap());
  }, get isObstacle() {
    return n;
  }, set cost(b) {
    s !== b && (s = b, this.getLevel().invalidateNavigationMap());
  }, get cost() {
    return s;
  }, set edges(b) {
    a = b, h = c(), this.getLevel().invalidateNavigationMap();
  }, get edges() {
    return a;
  }, get edgeMask() {
    return h;
  }, getLevel() {
    return this.parent;
  }, moveLeft() {
    this.tilePos = this.tilePos.add(E(-1, 0));
  }, moveRight() {
    this.tilePos = this.tilePos.add(E(1, 0));
  }, moveUp() {
    this.tilePos = this.tilePos.add(E(0, -1));
  }, moveDown() {
    this.tilePos = this.tilePos.add(E(0, 1));
  } };
}
o(Vr, "tile");
function is(t, e) {
  if (t == null) throw new Error("health() requires the initial amount of hp");
  return { id: "health", hurt(n = 1) {
    this.setHP(t - n), this.trigger("hurt", n);
  }, heal(n = 1) {
    let s = t;
    this.setHP(t + n), this.trigger("heal", t - s);
  }, hp() {
    return t;
  }, maxHP() {
    return e ?? null;
  }, setMaxHP(n) {
    e = n;
  }, setHP(n) {
    t = e ? Math.min(e, n) : n, t <= 0 && this.trigger("death");
  }, onHurt(n) {
    return this.on("hurt", n);
  }, onHeal(n) {
    return this.on("heal", n);
  }, onDeath(n) {
    return this.on("death", n);
  }, inspect() {
    return `${t}`;
  } };
}
o(is, "health");
function as(t, e = {}) {
  let n = re(this);
  if (t == null) throw new Error("lifespan() requires time");
  let s = e.fade ?? 0;
  return { id: "lifespan", require: ["opacity"], async add() {
    await n.wait(t), this.opacity = this.opacity ?? 1, s > 0 && await n.tween(this.opacity, 0, s, (a) => this.opacity = a, Lt.linear), this.destroy();
  } };
}
o(as, "lifespan");
function us(t) {
  return { name: t };
}
o(us, "named");
function cs(t, e, n) {
  if (!t) throw new Error("state() requires an initial state");
  let s = {};
  function a(p) {
    s[p] || (s[p] = { enter: new Se(), end: new Se(), update: new Se(), draw: new Se() });
  }
  o(a, "initStateEvents");
  function c(p, l, M) {
    return a(l), s[l][p].add(M);
  }
  o(c, "on");
  function h(p, l, ...M) {
    a(l), s[l][p].trigger(...M);
  }
  o(h, "trigger");
  let b = false;
  return { id: "state", state: t, enterState(p, ...l) {
    if (b = true, e && !e.includes(p)) throw new Error(`State not found: ${p}`);
    let M = this.state;
    if (n) {
      if (!(n == null ? void 0 : n[M])) return;
      let y = typeof n[M] == "string" ? [n[M]] : n[M];
      if (!y.includes(p)) throw new Error(`Cannot transition state from "${M}" to "${p}". Available transitions: ${y.map((P) => `"${P}"`).join(", ")}`);
    }
    h("end", M, ...l), this.state = p, h("enter", p, ...l), h("enter", `${M} -> ${p}`, ...l);
  }, onStateTransition(p, l, M) {
    return c("enter", `${p} -> ${l}`, M);
  }, onStateEnter(p, l) {
    return c("enter", p, l);
  }, onStateUpdate(p, l) {
    return c("update", p, l);
  }, onStateDraw(p, l) {
    return c("draw", p, l);
  }, onStateEnd(p, l) {
    return c("end", p, l);
  }, update() {
    b || (h("enter", t), b = true), h("update", this.state);
  }, draw() {
    h("draw", this.state);
  }, inspect() {
    return this.state;
  } };
}
o(cs, "state");
function Ur(t) {
  return { id: "stay", stay: true, scenesToStay: t };
}
o(Ur, "stay");
function Mn() {
  return { id: "timer", wait(t, e) {
    let n = re(this), s = [];
    e && s.push(e);
    let a = 0, c = this.onUpdate(() => {
      a += n.dt(), a >= t && (s.forEach((h) => h()), c.cancel());
    });
    return { get paused() {
      return c.paused;
    }, set paused(h) {
      c.paused = h;
    }, cancel: c.cancel, onEnd(h) {
      s.push(h);
    }, then(h) {
      return this.onEnd(h), this;
    } };
  }, loop(t, e) {
    let n = null, s = o(() => {
      n = this.wait(t, s), e();
    }, "newAction");
    return n = this.wait(0, s), { get paused() {
      return n.paused;
    }, set paused(a) {
      n.paused = a;
    }, cancel: o(() => n.cancel(), "cancel") };
  }, tween(t, e, n, s, a = Lt.linear) {
    let c = re(this), h = 0, b = [], p = this.onUpdate(() => {
      h += c.dt();
      let l = Math.min(h / n, 1);
      s(nt(t, e, a(l))), l === 1 && (p.cancel(), s(e), b.forEach((M) => M()));
    });
    return { get paused() {
      return p.paused;
    }, set paused(l) {
      p.paused = l;
    }, onEnd(l) {
      b.push(l);
    }, then(l) {
      return this.onEnd(l), this;
    }, cancel() {
      p.cancel();
    }, finish() {
      p.cancel(), s(e), b.forEach((l) => l());
    } };
  } };
}
o(Mn, "timer");
function ls(t = {}) {
  let e = re(this), { app: n, isFixed: s, getViewportScale: a, game: c } = e._k, h = {}, b = /* @__PURE__ */ new Set();
  return { id: "area", collisionIgnore: t.collisionIgnore ?? [], add() {
    this.area.cursor && this.onHover(() => n.setCursor(this.area.cursor)), this.onCollideUpdate((p, l) => {
      h[p.id] || this.trigger("collide", p, l), h[p.id] = l, b.add(p.id);
    });
  }, update() {
    for (let p in h) b.has(Number(p)) || (this.trigger("collideEnd", h[p].target), delete h[p]);
    b.clear();
  }, drawInspect() {
    let p = this.localArea();
    e.pushTransform(), e.pushScale(this.area.scale), e.pushTranslate(this.area.offset);
    let l = { outline: { width: 4 / a(), color: ie(0, 0, 255) }, anchor: this.anchor, fill: false, fixed: s(this) };
    p instanceof e.Rect ? e.drawRect({ ...l, pos: p.pos, width: p.width, height: p.height }) : p instanceof e.Polygon ? e.drawPolygon({ ...l, pts: p.pts }) : p instanceof e.Circle && e.drawCircle({ ...l, pos: p.center, radius: p.radius }), e.popTransform();
  }, area: { shape: t.shape ?? null, scale: t.scale ? E(t.scale) : E(1), offset: t.offset ?? E(0), cursor: t.cursor ?? null }, isClicked() {
    return n.isMousePressed() && this.isHovering();
  }, isHovering() {
    let p = s(this) ? e.mousePos() : e.toWorld(e.mousePos());
    return this.hasPoint(p);
  }, checkCollision(p) {
    return h[p.id] ?? null;
  }, getCollisions() {
    return Object.values(h);
  }, isColliding(p) {
    return !!h[p.id];
  }, isOverlapping(p) {
    let l = h[p.id];
    return l && l.hasOverlap();
  }, onClick(p, l = "left") {
    let M = n.onMousePress(l, () => {
      this.isHovering() && p();
    });
    return this.onDestroy(() => M.cancel()), M;
  }, onHover(p) {
    let l = false;
    return this.onUpdate(() => {
      l ? l = this.isHovering() : this.isHovering() && (l = true, p());
    });
  }, onHoverUpdate(p) {
    return this.onUpdate(() => {
      this.isHovering() && p();
    });
  }, onHoverEnd(p) {
    let l = false;
    return this.onUpdate(() => {
      l ? this.isHovering() || (l = false, p()) : l = this.isHovering();
    });
  }, onCollide(p, l) {
    if (typeof p == "function" && l === void 0) return this.on("collide", p);
    if (typeof p == "string") return this.onCollide((M, y) => {
      M.is(p) && l(M, y);
    });
  }, onCollideUpdate(p, l) {
    if (typeof p == "function" && l === void 0) return this.on("collideUpdate", p);
    if (typeof p == "string") return this.on("collideUpdate", (M, y) => M.is(p) && l(M, y));
  }, onCollideEnd(p, l) {
    if (typeof p == "function" && l === void 0) return this.on("collideEnd", p);
    if (typeof p == "string") return this.on("collideEnd", (M) => M.is(p) && l(M));
  }, hasPoint(p) {
    return pt(this.worldArea(), p);
  }, resolveCollision(p) {
    let l = this.checkCollision(p);
    l && !l.resolved && (this.pos = this.pos.add(l.displacement), l.resolved = true);
  }, localArea() {
    return this.area.shape ? this.area.shape : this.renderArea();
  }, worldArea() {
    let p = this.localArea();
    if (!(p instanceof e.Polygon || p instanceof e.Rect)) throw new Error("Only support polygon and rect shapes for now");
    let l = this.transform.clone().scale(E(this.area.scale ?? 1)).translate(this.area.offset);
    if (p instanceof e.Rect) {
      let M = Pt(this.anchor || It).add(1, 1).scale(-0.5).scale(p.width, p.height);
      l.translate(M);
    }
    return p.transform(l);
  }, screenArea() {
    let p = this.worldArea();
    return s(this) ? p : p.transform(c.cam.transform);
  }, inspect() {
    return `(${this.area.scale.x.toFixed(1)}, ${this.area.scale.y.toFixed(1)})`;
  } };
}
o(ls, "area");
function ms(t = {}) {
  let e = re(this), { calcTransform: n, game: s } = e._k, a = null, c = null, h = false;
  return { id: "body", require: ["pos"], vel: E(0), drag: t.drag ?? 0, jumpForce: t.jumpForce ?? Ko, gravityScale: t.gravityScale ?? 1, isStatic: t.isStatic ?? false, mass: t.mass ?? 1, add() {
    if (this.mass === 0) throw new Error("Can't set body mass to 0");
    this.is("area") && (this.onCollideUpdate((b, p) => {
      if (!b.is("body") || p.resolved) return;
      this.trigger("beforePhysicsResolve", p);
      let l = p.reverse();
      if (b.trigger("beforePhysicsResolve", l), !(p.resolved || l.resolved) && !(this.isStatic && b.isStatic)) {
        if (!this.isStatic && !b.isStatic) {
          let M = this.mass + b.mass;
          this.pos = this.pos.add(p.displacement.scale(b.mass / M)), b.pos = b.pos.add(p.displacement.scale(-this.mass / M)), this.transform = n(this), b.transform = n(b);
        } else {
          let M = !this.isStatic && b.isStatic ? p : p.reverse();
          M.source.pos = M.source.pos.add(M.displacement), M.source.transform = n(M.source);
        }
        p.resolved = true, this.trigger("physicsResolve", p), b.trigger("physicsResolve", p.reverse());
      }
    }), this.onPhysicsResolve((b) => {
      s.gravity && (b.isBottom() && this.isFalling() ? (this.vel = this.vel.reject(s.gravity.unit()), a = b.target, c = b.target.pos, h ? h = false : this.trigger("ground", a)) : b.isTop() && this.isJumping() && (this.vel = this.vel.reject(s.gravity.unit()), this.trigger("headbutt", b.target)));
    }));
  }, update() {
    if (s.gravity && !this.isStatic) {
      h && (a = null, c = null, this.trigger("fallOff"), h = false);
      let b = true;
      if (a && (!this.isColliding(a) || !a.exists() || !a.is("body") ? h = true : (!a.pos.eq(c) && t.stickToPlatform !== false && this.moveBy(a.pos.sub(c)), c = a.pos, b = false)), b) {
        let p = this.vel.clone();
        this.vel = this.vel.add(s.gravity.scale(this.gravityScale * e.dt()));
        let l = t.maxVelocity ?? qo;
        this.vel.slen() > l * l && (this.vel = this.vel.unit().scale(l)), p.dot(s.gravity) < 0 && this.vel.dot(s.gravity) >= 0 && this.trigger("fall");
      }
    }
    this.vel.x *= 1 - this.drag, this.vel.y *= 1 - this.drag, this.move(this.vel);
  }, onPhysicsResolve(b) {
    return this.on("physicsResolve", b);
  }, onBeforePhysicsResolve(b) {
    return this.on("beforePhysicsResolve", b);
  }, curPlatform() {
    return a;
  }, isGrounded() {
    return a !== null;
  }, isFalling() {
    return this.vel.dot(e.getGravityDirection()) > 0;
  }, isJumping() {
    return this.vel.dot(e.getGravityDirection()) < 0;
  }, jump(b) {
    a = null, c = null, this.vel = e.getGravityDirection().scale(-b || -this.jumpForce);
  }, onGround(b) {
    return this.on("ground", b);
  }, onFall(b) {
    return this.on("fall", b);
  }, onFallOff(b) {
    return this.on("fallOff", b);
  }, onHeadbutt(b) {
    return this.on("headbutt", b);
  } };
}
o(ms, "body");
function ds(t = 2) {
  let e = t;
  return { id: "doubleJump", require: ["body"], numJumps: t, add() {
    this.onGround(() => {
      e = this.numJumps;
    });
  }, doubleJump(n) {
    e <= 0 || (e < this.numJumps && this.trigger("doubleJump"), e--, this.jump(n));
  }, onDoubleJump(n) {
    return this.on("doubleJump", n);
  }, inspect() {
    return `${e}`;
  } };
}
o(ds, "doubleJump");
function Bn(t) {
  if (!t) throw new Error("Please define an anchor");
  return { id: "anchor", anchor: t, inspect() {
    return typeof this.anchor == "string" ? this.anchor : this.anchor.toString();
  } };
}
o(Bn, "anchor");
function Dr() {
  return { id: "fixed", fixed: true };
}
o(Dr, "fixed");
function hs(t, e) {
  return { id: "follow", require: ["pos"], follow: { obj: t, offset: e ?? E(0) }, add() {
    t.exists() && (this.pos = this.follow.obj.pos.add(this.follow.offset));
  }, update() {
    t.exists() && (this.pos = this.follow.obj.pos.add(this.follow.offset));
  } };
}
o(hs, "follow");
function ps(t) {
  let e = re(this), { game: n } = e._k, s = n.layers.indexOf(t);
  return { id: "layer", get layerIndex() {
    return s;
  }, get layer() {
    return e.layers[s];
  }, set layer(a) {
    if (s = n.layers.indexOf(a), s == -1) throw Error("Invalid layer name");
  }, inspect() {
    return `${this.layer}`;
  } };
}
o(ps, "layer");
function fs(t, e) {
  let n = typeof t == "number" ? B.fromAngle(t) : t.unit();
  return { id: "move", require: ["pos"], update() {
    this.move(n.scale(e));
  } };
}
o(fs, "move");
function gs(t = {}) {
  let e = re(this), n = t.distance ?? Ho, s = false;
  return { id: "offscreen", require: ["pos"], isOffScreen() {
    let a = this.screenPos(), c = new ce(E(0), e.width(), e.height());
    return !e.testRectPoint(c, a) && c.sdistToPoint(a) > n * n;
  }, onExitScreen(a) {
    return this.on("exitView", a);
  }, onEnterScreen(a) {
    return this.on("enterView", a);
  }, update() {
    this.isOffScreen() ? (s || (this.trigger("exitView"), s = true), t.hide && (this.hidden = true), t.pause && (this.paused = true), t.destroy && this.destroy()) : (s && (this.trigger("enterView"), s = false), t.hide && (this.hidden = false), t.pause && (this.paused = false));
  } };
}
o(gs, "offscreen");
function Gn(t) {
  return t.fixed ? true : t.parent ? Gn(t.parent) : false;
}
o(Gn, "isFixed");
function sn(...t) {
  let e = re(this), { getViewportScale: n } = e._k;
  return { id: "pos", pos: E(...t), moveBy(...s) {
    this.pos = this.pos.add(E(...s));
  }, move(...s) {
    this.moveBy(E(...s).scale(e.dt()));
  }, moveTo(...s) {
    if (typeof s[0] == "number" && typeof s[1] == "number") return this.moveTo(E(s[0], s[1]), s[2]);
    let a = s[0], c = s[1];
    if (c === void 0) {
      this.pos = E(a);
      return;
    }
    let h = a.sub(this.pos);
    if (h.len() <= c * e.dt()) {
      this.pos = E(a);
      return;
    }
    this.move(h.unit().scale(c));
  }, worldPos(s = null) {
    if (s) this.pos = this.pos.add(this.fromWorld(s));
    else return this.parent ? this.parent.transform.multVec2(this.pos) : this.pos;
  }, toWorld(s) {
    return this.parent ? this.parent.transform.multVec2(this.pos.add(s)) : this.pos.add(s);
  }, fromWorld(s) {
    return this.parent ? this.parent.transform.invert().multVec2(s).sub(this.pos) : s.sub(this.pos);
  }, screenPos(s = null) {
    if (s) this.pos = this.pos.add(this.fromScreen(s));
    else {
      let a = this.worldPos();
      return Gn(this) ? a : e.toScreen(a);
    }
  }, toScreen(s) {
    let a = this.toWorld(s);
    return Gn(this) ? a : e.toScreen(a);
  }, fromScreen(s) {
    return Gn(this) ? this.fromWorld(s) : this.fromWorld(e.toWorld(s));
  }, toOther(s, a) {
    return s.fromWorld(this.toWorld(a));
  }, fromOther(s, a) {
    return s.toOther(this, a);
  }, inspect() {
    return `(${Math.round(this.pos.x)}, ${Math.round(this.pos.y)})`;
  }, drawInspect() {
    e.drawCircle({ color: e.rgb(255, 0, 0), radius: 4 / n() });
  } };
}
o(sn, "pos");
function bs(t) {
  return { id: "rotate", angle: t ?? 0, rotateBy(e) {
    this.angle += e;
  }, rotateTo(e) {
    this.angle = e;
  }, inspect() {
    return `${Math.round(this.angle)}`;
  } };
}
o(bs, "rotate");
function an(...t) {
  let e = re(this), { toFixed: n } = e._k;
  return t.length === 0 ? an(1) : { id: "scale", scale: E(...t), scaleTo(...s) {
    this.scale = E(...s);
  }, scaleBy(...s) {
    this.scale.scale(E(...s));
  }, inspect() {
    return `(${n(this.scale.x, 2)}, ${n(this.scale.y, 2)})`;
  } };
}
o(an, "scale");
function ys(t) {
  return { id: "z", z: t, inspect() {
    return `${this.z}`;
  } };
}
o(ys, "z");
var vs = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD0AAAA1CAYAAADyMeOEAAAAAXNSR0IArs4c6QAAAoVJREFUaIHdm7txwkAQhheGAqACiCHzOKQDQrqgILpwSAeEDBnEUAF0gCMxZ7G72qce/mec2Lpf9+3unaS78wgSNZ8uX5729+d1FNWXUuGmXlBOUUEIMckEpeQJgBu6C+BSFngztBR2vd+ovY+7g+p6LbgaWgJrAeUkDYIUXgXdBBwNi6kpABJwMTQH3AZsXRR8GHTfgEth8E3gjdAUcNewpbTgY85sCMCUuOokozE0YM0YRzM9NGAAXd8+omAF5h4lnmBRvpSnZHyLoLEbaN+aKB9KWv/KWw0tAbbANnlG+UvB2dm77NxxdwgBpjrF/d7rW9cbmpvio2A5z8iAYpVU8pGZlo6/2+MSco2lHfd3rv9jAP038e1xef9o2mjvYb2OqpqKE81028/jeietlSEVO5FRWsxWsJit1G3aFpW8iWe5RwpiCZAk25QvV6nz6fIlynRGuTd5WqpJ4guAlDfVKBK87hXljflgv1ON6fV+4+5gVlA17SfeG0heKqQd4l4jI/wrmaA9N9R4ar+wpHJDZyrrfcH0nB66PqAzPi76pn+faSyJk/vzOorYhGurQrzj/P68jtBMawHaHBIR9xoD5O34dy0qQOSYHvqExq2TpT2nf76+w7y251OYF0CRaU+J920TwLUa6inx6OxE6g80lu2ux7Y2eJLF/rCXE6zEPdnenk9o+4ih9AEdnW2q81HXl5LuU6OTl2fXUhqganbXAGq3g6jJOWV/OnoesO6YqqEB/GdNsjf7uHtwj2DzmRNpp7iOZfm6D9oAxB6Yi1gC4oIYeo4MIPdopEQRB+cAko5J1tW386HpB2Kz1eop4Epdwls/kgZ1sh8gZsEjdcWkr//D8Qu3Z3l5Nl1NtAAAAABJRU5ErkJggg==";
var xs = "data:image/png;base64,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";
var ws = zr("SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAASAAAeMwAUFBQUFCIiIiIiIjAwMDAwPj4+Pj4+TExMTExZWVlZWVlnZ2dnZ3V1dXV1dYODg4ODkZGRkZGRn5+fn5+frKysrKy6urq6urrIyMjIyNbW1tbW1uTk5OTk8vLy8vLy//////8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAQKAAAAAAAAHjOZTf9/AAAAAAAAAAAAAAAAAAAAAP/7kGQAAANUMEoFPeACNQV40KEYABEY41g5vAAA9RjpZxRwAImU+W8eshaFpAQgALAAYALATx/nYDYCMJ0HITQYYA7AH4c7MoGsnCMU5pnW+OQnBcDrQ9Xx7w37/D+PimYavV8elKUpT5fqx5VjV6vZ38eJR48eRKa9KUp7v396UgPHkQwMAAAAAA//8MAOp39CECAAhlIEEIIECBAgTT1oj///tEQYT0wgEIYxgDC09aIiE7u7u7uIiIz+LtoIQGE/+XAGYLjpTAIOGYYy0ZACgDgSNFxC7YYiINocwERjAEDhIy0mRoGwAE7lOTBsGhj1qrXNCU9GrgwSPr80jj0dIpT9DRUNHKJbRxiWSiifVHuD2b0EbjLkOUzSXztP3uE1JpHzV6NPq+f3P5T0/f/lNH7lWTavQ5Xz1yLVe653///qf93B7f/vMdaKJAAJAMAIwIMAHMpzDkoYwD8CR717zVb8/p54P3MikXGCEWhQOEAOAdP6v8b8oNL/EzdnROC8Zo+z+71O8VVAGIKFEglKbidkoLam0mAFiwo0ZoVExf/7kmQLgAQyZFxvPWAENcVKXeK0ABAk2WFMaSNIzBMptBYfArbkZgpWjEQpcmjxQoG2qREWQcvpzuuIm29THt3ElhDNlrXV///XTGbm7Kbx0ymcRX///x7GVvquf5vk/dPs0Wi5Td1vggDxqbNII4bAPTU3Ix5h9FJTe7zv1LHG/uPsPrvth0ejchVzVT3giirs6sQAACgQAAIAdaXbRAYra/2t0//3HwqLKIlBOJhOg4BzAOkt+MOL6H8nlNvKyi3rOnqP//zf6AATwBAKIcHKixxwjl1TjDVIrvTqdmKQOFQBUBDwZ1EhHlDEGEVyGQWBAHrcJgRSXYbkvHK/8/6rbYjs4Qj0C8mRy2hwRv/82opGT55fROgRoBTjanaiQiMRHUu1/P3V9yGFffaVv78U1/6l/kpo0cz73vuSv/9GeaqDVRA5bWdHRKQKIEAAAAoIktKeEmdQFKN5sguv/ZSC0oxCAR7CzcJgEsd8cA0M/x0tzv15E7//5L5KCqoIAAmBFIKM1UxYtMMFjLKESTE8lhaelUyCBYeA2IN4rK1iDt//+5JkEgAkZzlVq29D8DJDWo0YLLARwPFZrL0PyLsUazTAlpI+hKSx01VSOfbjXg0iW9/jVPDleLJ15QQA4Okdc5ByMDFIeuCCE5CvevwBGH8YibiX9FtaIIgUikF42wrZw6ZJ6WlHrA+Ki5++NNMeYH1lEkwwJAIJB4ugVFguXFc20Vd/FLlvq1GSiSwAFABABABA47k6BFeNvxEQZO9v3L1IE4iEVElfrXmEmlyWIyGslFA55gH/sW7////o9AAFIBIIAAIUMzYTTNkgsAmYObfwQyzplrOmYvq0BKCKNN+nUTbvD7cJzvHxrEWG5QqvP8U1vFx6CwE8NoRc2ADBeEb/HoXh60N7ST8nw9QiiGoYvf/r6GtC9+vLwXHjaSkIp3iupC5+Nii81Zhu85pNYbFvrf+UFThDOYYY26off+W6b//73GTiN9xDfl0AAwBAiMBO8qsDBPOZtuT/dTbjVVbY/KSGH6ppHwKv/6X+s8gUCN/lODzv////GQAGAMQAADlXAUCBJiY0wFQZusYQOaQzaTwDBTcx0IvVp8m7uxKp//uSZBMCBHRI1eNPLHAyxNqWGeoYUIEnWYyxD8DUFSn0l6iojcd+oEOkzV6uWqyHNzjqmv+7V5xGUfY9yEmbziTzjRscm9OqFQp1PKFrqu3PX/7YuGtDU6bt0OUTpv38rdc+37dVDQLKUchaJ853E9edNDGqWwsYz1VoiSStEJtZvw6+sNqFWqaIXJjQCGAAGWAYVwmag/x3BRJw1wYF7IzVqDcNzn85d//FzK7IgwbQwccLoB4AsF8Nj/1ESRUAAVJwAFh0YOFEhmSJEHKQRDyhszgLUpHIgFrb5cySFg5jv10ImlYuvaaGBItfXqnNPmic+XNkmb5fW49vdhq97nQMQyGIlM2v8oQSrxKSxE4F1WqrduqvuJCRof1R7Gsre9KszUVF1/t3PzH2tnp+iSUG3rDwGNcDzxCGA8atuQF0paZAAkAhAQAEAC240yJV+nJgUrqq8axAYtVpYjZyFGb13/17jwiClQDaCdytZpyHHf1R/EG/+lUAgAAAChhmJvioVGGBCFgqdpsGAkUUrbTstwTCJgLQpFIsELW7t/68Iv/7kmQUgAQ9NFO9aeAAPAU6RKwUABClY2e5hoARGpDvPydCAsY8WO10fSvUOnfT98+n/l/6/+hxslhQ1DEOaevNKGocvIYba8WJpaP/15pX0NQ1DUNn/////k6lPp/N61rBi8RJFfERV3IgrqDsJA64sjCoKxDDQ9xEcWDpMBDwVFDIAEIAAzryxsjGi4q/oWpixKjhklAF4pUrDPjFhFVupDFZ/t/t0YPAygUBhADPR/KLCKJ8h2Oxhpxz/zNRAAFl0MAZLAYEAiVbEiz36LSgZ5QoQVat69KNy8FyM5Z80ACHAzgnISEkxUSJIDyBSwi5KF4mjBl4xJdbrG9ComLrL8YATiodhQKCkj6ROdyg1y5XmZlvMVmpJzYppJDwLi/Lp9vT3TfmimOGpuezi2U/9FNav0zX9Oja2r//8+hvuihuQAAMAVmqFgAgCcuboAEAAAUcqy8ca0BHBmwbFkED0CNA1YYDPkhcQrRJxcY3BzfxxltAz9vX62Xl3plAzWmRO+FkZyH///1qAAEjQBAACUpgU5o2AIBmFBGMamrGg0b/+5JkC4ADxyLWb2ngAEEkGofsoACP7U1JLaxTkOqFaKhspGgnW3SGC56ZgUJGCRnLOmIJAkuNBgvwU4Ocf8CJK9UsafH9/Frj///365XSoME+DZMw5UNjrMbVoeIj9EL91IuQ5KHyl5V2LCpdIdESgafOHxVGkAlkHuakmix/gN8+BP/sKguLAAoAtUjtvaoeEADwr3OK11E4KBlojgeQNQBJ4MvCAd/4t/xMMzeLhQGQ1//6tQu5BaBOGCT6U4aafvXZ//4iAPAAAAbLkgIlQmMSLA2H1CVNAlWwyVvKIQIxOSK1NWxs4MBUATlKrAkIMPAjCAdS6MVFzuURWa/+/qQWEGsA6EEpiBEJb9Q21lAHoBoD0B6aAPhyt+bG3muoXIN3RLadXxUfr/ohjGFF/p97eqNI5noKAqYLNPpUTDSI9/TmA6B+YAAADgA0Y4lxTW1SQfOQuDDDI0KTTuIrF5qoJrUFhUFAsg+AT2hbkaRZYGIjBKVDIa5VgNN/9P/rCDsBJbYJRKpCA1ArAkigIeYY61AjE+jubyiZFZ3+L789//uSZBCABHVj2entNmw1JXokLycYEFTFVa0wz4DYjKs08J2Q+r4n3lgbWaaMwMLEjFW88F39brqPF83cv1mCSJeY3Q2uiQxhBJxCBeR1D2LQRsYQcZUTzdNll8+OwZBsIwSgl45ymaHX603Mz7JmZuvt71GDTN66zev/+cLn/b5imV8pAHkg61FIJchBSG+zycgAZgADD6F1iQQRXRWmWS6bDIIgyBCZEcdl/KgXGmVKFv/vl8ry/5bLypf//U5jhYDhL9X/pAA0AKBIAAKgGtGXGGWJgEoF2JNsHlKfSKLRhGBAgIuWZKIJCFpF1VBhkB+EfzEyMUJdWuMrEZoPZ5BfF3/Nu62riIdjoO4AAKD2sTrDmpZZaYysf/810TitAVvn9xtFucieiaEy54YqiIO6RqkGAm5wVO0bFB0sDTdNxYGekKktR4KAAfAwUIgI8Ci6aXgtwbhPWAC+CKExAFydNtYGXNZoQjUsXv/9vKjgmdwieb+h7kHvPoc//0FaCACAATKFC4Y9ammklidbaiJNPBhGWTNhFSgdtalK12lpl//7kmQRAFN2NFI7TBvwNKNaTRsFGBWdfV2tPNcYvBHpgPKJsc8IUcTCxY3HSvUVNTWe/Z3YWlrJ0yrNRUiT19aprA7E+mPP+ZmC3/CsheOJXhc/9VJb3UZnphUBcqZUZQth1i3XqtPYu2Sy1s8DV9ZYACAAASAAHgFkQcOqgB5utFHFh3kSi4USs0yk4iOClREmjvdG+upaiLcRA6/9QGbOfxF/8sEAQAVG0G07YFMihKR4EXJCkRdX9isueLqUMRAQdhDZmv3KeR0nPqRVrZmSIXDt+BBSR7qqbKQcB98W9qiMb55preHIStxFWPE4lAyI+BKz2iSxonpvMR5DgKxTH6vGGXAbYCaAnJUW4W07EesQqbfqdbo4qNnPxSpn1H8eahszc/y9//dn1V7D/OYpn1szQKAPXTMlO/rO//u7JriJXbld7aP33v6RXYg/COIDzTWkTspg6Ay1YaDSwKxrP/LfIikHjmO871POf/kEAseAgoPEi9/0ZziNwfxVKy9qAEGEEAAq1EcOamDEGHAA0iao8k31rz2MiLNEik6VQ37/+5JkEAgEYU5WU0M3MDjDe0o9IjiOzSVM7aCzEM2GqXD8pFB0zxMcHCQNHtZD+R+pMWZxOJ/otEZTvVN/MeU12xTVcL+f2YaiNJTVoPd6SvzEnKel5GXOzEaazgdChnP2jOAwpfyRpVlQwoJBwpN1L1DL////6TVWcoepf7CVWrpEWiym5lR5U0BSMlxQC4qByOyQIAEuJfIriWixDqRgMfVZWuvRowjR9BzP5lZlT/+YG50CsSBG////////liXDQVMxEaBkbzKAAACnDIAstY7iK7gGSF7SIDexaTtPOHABk9YcmJEACmo50pgWal22etroBpYoVqtU6OPqvlf0c4QCAfLk9P/FJs4KCQMf6ECZyA6BwqqyJ0rMYj56k1/UlTIx1V3Rt5NF71D4qlptDC8VMgQVHFDlQnDFi06qQgKQAAIK4TxxJGFGYJuZNGXRdpq7IW/DYpPIQRFJLAc+qn1E0XYdOkQVJT+z8Lvff//8vbKAWTIBBUUdM6cOhlDry7x4dAkJXIBhbO3HSMMMGBQ9K9/JNfu09PjTO64wYEcR//uSZBeABP5g11NPRVwzQ4r8PMJVj7j9UU2wUwDPjeq0Z5w675D9+uDdL2QsuIry2lZtwn/pJYyRRjANEOQxNWw8mU7Tq+vueV7JrX/Pg7VIkEuZT5dwd85MVoq5lpStNICkBAcFR88//58KO8Zjt2PIGxWl1cVfXeNGH18SReNT//hYliWtQuNluxyxONbm4U+lpkAgpyE7yAIYUjIaqHmARJ0GQTtmH60xdwFp/u253XBCxD0f/lBcguCALn//Y5nqEv//1h4BAAwgAA5gcHmpIplgeW9fAOM6RFZUywrsGAiRmKkanQnCFBjYoPDS7bjwtPTkVI8D/P8VVLcTUz65n7PW2s3tNYHgEul4tBaIz0A9RgJAyAMI4/i0fpQKjhX9S+qIa0vmc4CZit/0/3UTDGeKNpkk0nu2rUE2ag8WErhE/kgAiQCJKQEYBA5Wn6CxHoIUh6dQ46nLIuwFk4S/LaDQxXu7Yf/pf//lwJB0S/Ff/4C///EiBEiAAAIAMnpngiIABAdMpKigkXaUwhLEGvpiofmXW57h2XAZO3CMRv/7kmQUAEOHQlHraRTQMkQp6GWFZBTVU1lNPTPYyIyocYeUoNgLBWAs1jPkTv/tXBaeZ/tbD/nAGP8/xT0SNEi5zof0KIVEzVe9r5lZOol7kyaXMYS4J/ZS3djp//UaeVyR0mUMlTgfz8XqMzIEgAQQ6UNQ1DSE0/C16OvyaocF4ijAGFci0FSYqCUSaWs6t9F6/699DKvMgMoK1//kSbvxtyBN27I7mdXgNMAW75sRU1UwUHYG5axI2tFIFpkgx7nnK+1JmRKjqeAd5Ph0QAL4QAnirmiPlg0yBDlrb/d3ngtA65rb999+8vdDCfnJuJAYIl285zklpVbrKpk1PEzrOY9NZUgyz6OiOsKt5qG/g2ibxSZ+/eTI/NB8n4ev//n2nIw85GAdwuJL7kYnnAbpcf1RBKH6b2U4RWP8dmWH5snsAFYwADBgAopKdzFJq4Jlmotloh/m4QpTSvJRE3nYZHephoqBhVf+P7vQ9BPlwZCP+3//+hdy5uUwS3LDEgQx4cdIgvDEBR1YqymCsSbKzRy2aQmSv+AAcAgAkvzPfuX/+5JkFQAj6VFX00Zr5DllOhhgpn4MmSs+zSRRiO8U5tWklYgSLKfs+Xheb/+6WaAQCKTztNeJ382MUltZNnjSJoFrCqB6C4mFcwJpJD4Oc8dLDXMTh9k1/rmTopfzqv9AvHWfOuZJlEvHSVMjyjpkVucKSzxJVQBgAAIo8DGqRdYCXPckFYg+dH9A/qUyljrtpxH9RJX/Z3Vv6uFkPg4M2jf3CL09QrwOrMt69n//8UFEAAMHWdhg1CcjyVBwiArOYlDL5NPY6x8ZLFBCGi6SVTKX5nqdSEFjebnv2zHdt0dj6xvORsSFzwqRNTJSZIrrlpXcURNL9WW7krBgr5jPMaGcvJ5v0N1s19CV7+7fvQfjySX2QECWUgKgeJCIif4WRBZ/6archpDkzE7oWctK3zEHP9Smeai8oeHkM6AK7pGjtOgeFv40ugqNd+Iv///uAZAMgAAAUeSWhLPpdwk3iXpBw43hOVIp1gliUOSaeZcZeZhLAH9TtD56wUpBduzLF5v5qViTH6o+I0+8Z1asaLgKVAohlpB72DgAQBQxEd3g//uSZCiAA6k0UdMPQfA+xcnBYON8E3WDVU0w1ZjPDSmo8IniHAFDNnkXF3B94gicH5d8MFw+IHZwufxOf/8gsHw+XrD4Jn8T4RAyQiABNBQg/3giEWuZ42mVFB3kkXNjhqBg1CghEUbN3/7/KBhyqNueef/MIDBClP3YRnKLiIlEFzf//0g+4zKpRIKTpqQgUtnHGFw6RSLN421iGcYapqFxny/capK9r9v+2BSy/RU1yZxa2eGaWK07ijfcxeiO3iuHJvjbXzts+Ny+XyFnsne1h0qG4mAaN6xRGaLVxKPlrri0Bg9oXGyxcw8JRBPkUzC8v451vVd9liSX85JMrmkVNwxOCwUg298////7ks//L409/hwMRIozKiIckXtjzDaAMTBcAACAwLGargPSEgEJZN/EFjfF/VKgaMYKMbwtf/T0UCGGfjfOAZ2frCigYdwh/+sGlQBxhCAAAUHkDPqOdmmUdAVYl3IhrEfR8qZFjLYEPOyzVGvm6lNUJCk2PNazwFxaijk+ZEaiTehoJGuDh6zN/EVP8BCLD/88BoY7Xv/7kmQlgBNmMtNTL0FwOGZJ/WHiKAyhJU+soE3A3JnmAa2oaCIru/+RrEHMTphxQ0X/LzoVy4gKhYl6ZUlklW7CLRVoYmgABwCRMAAMA/poCiEEYLsBVodWcVZ18+CcAfH165U4Xgh7/X1/BAQF6GN/BwQ/+D9S9P6wII//CoANYFYCBAKlGQDKhVjjylKARw2mPAtp8JjcQHggQswVsOEKsF6AIBWvmpIFdSZvRVv/LHWEy0+txMxu+VK9gEqG5pWf6GNGU4UBVkfd+bsj/6lZE0fkOpAqAOvyUO9oo+IiEtcLKOGzhhSGa4MYINHWoQsFr8zzmow0tRILkqz5/+vFxl/oZX/+qGW//xiLjR3xcGn//0QLkTQJh1UA8MAQAEXC/YxODKTDUEhrASs1512GRp+dRFFdTWIRaOXrve1eNjTNpreqQYrC9NBlQc1f8YO2po8bnH6qffuRvU7taiNF3baokE0YpmjRCHRclWBb9NCHKHpERwHRG3pqgXklq4sBpLjGvmekg8Y7SjM1FZopIM8IhB6dtMr8aKsdovh4FW//+5JkQ4CjTDdSU0gtIDiE+YBrKgwNbSVJTCBPwN8N5ZW8NKDnhRB8AXCm//KAsBUCwKU//oJQnET+UP3/zpYRocAAABJkVzzIuoLGEaDoxfsNva12EUdxhJMGFQioSg8GxKsLm8kWEmExJuNidarkk+OTXc0i2OZEq2v+tZr/MDZRS0I7LfRpHdlsiF6m/mEjk+XlK10UqtKYUwNgMx24hUtCJLfpM3ExUeKDYjClgZAzAjQ0qlNQBTsGpk9zSRkCiKkRGp572VXsPYChGvxhAuYkDYZK//jSRgto2mTf6+PJqgAAgIAAAACYZE6aZOHhYkYlcbpeYQq1RgLO4U8TIlL1sGw+iKZi5Kzc/bKT0yXrIUMES89RCWy8oWlxqIQlKANLFpT/KjUrK+UCYbZqGnjVj29aO5dzofWAskRX5eJWPi4kf/aRVjy3Wlyg2AnMYIDSTLwZUTASIzflPWUwwlUnIFMnGiyABeaXJcN91PmQJCLzmvUJkFOHCrX/+6O///IHnT4tT9YYBoNMQ09GfKIErwdwChNz1Qy5+5S/wWeY//uSZF+C03UyT2tMO0A3RRkhY20KzQjDMszhA8DjlGOBp5y4ZCS3ica52GIGiryv7FAaSDVZSXKFTiir+GvGiuK4rjgwPVTddso+W/42a4ueJJHDYtfj6YoKknnjzRgKA0fBIRZOSsprJqnoNN73ps/Z9DVgbKNbMGmRzrYBMAZCPUANkAZQ0syAC2ubK1NF90+WoesBpnhY8qwVDkNb/5Uof6//418TgElCSgAIgyAAQBHEmiaQFPIRmfAMELffpo0IflyEuAAQnSnKvwTlVlnIgOAAGS3P3IydjXPSh/CaVRqpSNCjQqDvPM+fLcuN+WgqNix6CoHomUWTT86JjziRSZ3yjnq+dIldKPU11KUuf6wAASMAAJxE+MlyktgE9UGSxjEx6RR0v1s9bWZ+EJSrGtjqUIhklG3J8eLRn/2U/nv7f///+7/6gBQgEAMUijVMwweWWMyYM/PLXuc7DptIQmBARMRCxXjEIcTNDQgSSeHpUNXO7dRSOllJPvnY7yzaO1hmUjsKvHe99fOxrabMX7mGTi5tsNkZVZLndzxse//7kmR7ABM2O0pbKTvQN4NI+WGFPA2ZESs1pYAAvA0jVrJwAHfbr/c6//vW790dzX36QNBRlDv/6QQAU3V64yUgBEAYc/lI8e5bm+Z9+j+4aaj4tFrb//iker/4a12b/V//q//9v+7vAEAAAAMqZTGd5gL4f54o6ZebKNrR/zWVYUEVYVVv8BuAV2OUT+DUQgkJ8J1Ey4ZbFCiAwgwzMSdHV4jQR+OoPWEASaPkyYq+PsQFFJCsEEJtOiUjI/+GRhtC2DnizTMXATJig9Ey/kAJMrkHGYJ8gpLjmJOYoskpav+ShRJInyGGZVJMihDi6pIxRZJJel/8iZPkYiREnyKE0akTL5QNSqT5iiySS9Ja2SV//5ME0ak//+4KgAAABgQBAADAMDgYCAEgCteQ0fZH6+ICXA357+MPfhR/+ywRf/U///LVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX/+5JknQAFoWhGLm5gBClBmT3GiAAAAAGkHAAAIAAANIOAAARVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV");
var Cs = "data:image/png;base64,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";
var xa = "3001.0.0";
function Pt(t) {
  switch (t) {
    case "topleft":
      return new B(-1, -1);
    case "top":
      return new B(0, -1);
    case "topright":
      return new B(1, -1);
    case "left":
      return new B(-1, 0);
    case "center":
      return new B(0, 0);
    case "right":
      return new B(1, 0);
    case "botleft":
      return new B(-1, 1);
    case "bot":
      return new B(0, 1);
    case "botright":
      return new B(1, 1);
    default:
      return t;
  }
}
o(Pt, "anchorPt");
function wa(t) {
  switch (t) {
    case "left":
      return 0;
    case "center":
      return 0.5;
    case "right":
      return 1;
    default:
      return 0;
  }
}
o(wa, "alignPt");
function Ca(t) {
  return t.createBuffer(1, 1, 44100);
}
o(Ca, "createEmptyAudioBuffer");
var Ze;
var Ta = o((t) => t && t.loadAseprite, "isKaboomCtx");
var re = o((t) => {
  if (!Ze) throw new Error("You are trying to access to Kaboom Context before their initialization.");
  return Ta(t) ? t : Ze;
}, "getKaboomContext");
var Sa = o((t = {}) => {
  let e = t.root ?? document.body;
  e === document.body && (document.body.style.width = "100%", document.body.style.height = "100%", document.body.style.margin = "0px", document.documentElement.style.width = "100%", document.documentElement.style.height = "100%");
  let n = t.canvas ?? e.appendChild(document.createElement("canvas")), s = t.scale ?? 1, a = t.width && t.height && !t.stretch && !t.letterbox;
  a ? (n.width = t.width * s, n.height = t.height * s) : (n.width = n.parentElement.offsetWidth, n.height = n.parentElement.offsetHeight);
  let c = ["outline: none", "cursor: default"];
  if (a) {
    let r = n.width, i = n.height;
    c.push(`width: ${r}px`), c.push(`height: ${i}px`);
  } else c.push("width: 100%"), c.push("height: 100%");
  t.crisp && (c.push("image-rendering: pixelated"), c.push("image-rendering: crisp-edges")), n.style.cssText = c.join(";");
  let h = t.pixelDensity || window.devicePixelRatio;
  n.width *= h, n.height *= h, n.tabIndex = 0;
  let b = document.createElement("canvas");
  b.width = 256, b.height = 256;
  let p = b.getContext("2d", { willReadFrequently: true }), l = Do({ canvas: n, touchToMouse: t.touchToMouse, gamepads: t.gamepads, pixelDensity: t.pixelDensity, maxFPS: t.maxFPS, buttons: t.buttons }), M = [], y = l.canvas.getContext("webgl", { antialias: true, depth: true, stencil: true, alpha: true, preserveDrawingBuffer: true }), P = Tr(y, { texFilter: t.texFilter }), v = (() => {
    let r = jt(Rn, Pn), i = Xe.fromImage(P, new ImageData(new Uint8ClampedArray([255, 255, 255, 255]), 1, 1)), u = t.width && t.height ? new At(P, t.width * h * s, t.height * h * s) : new At(P, y.drawingBufferWidth, y.drawingBufferHeight), m = null, f = 1;
    t.background && (m = ie(t.background), f = Array.isArray(t.background) ? t.background[3] : 1, y.clearColor(m.r / 255, m.g / 255, m.b / 255, f ?? 1)), y.enable(y.BLEND), y.blendFuncSeparate(y.SRC_ALPHA, y.ONE_MINUS_SRC_ALPHA, y.ONE, y.ONE_MINUS_SRC_ALPHA);
    let w = new On(P, An, Io, Lo), x = Xe.fromImage(P, new ImageData(new Uint8ClampedArray([128, 128, 128, 255, 190, 190, 190, 255, 190, 190, 190, 255, 128, 128, 128, 255]), 2, 2), { wrap: "repeat", filter: "nearest" });
    return { lastDrawCalls: 0, defShader: r, defTex: i, frameBuffer: u, postShader: null, postShaderUniform: null, renderer: w, transform: new Le(), transformStack: [], bgTex: x, bgColor: m, bgAlpha: f, width: t.width ?? y.drawingBufferWidth / h / s, height: t.height ?? y.drawingBufferHeight / h / s, viewport: { x: 0, y: 0, width: y.drawingBufferWidth, height: y.drawingBufferHeight }, fixed: false };
  })();
  const _j = class _j {
    constructor(i, u, m = {}, f = null) {
      __publicField(this, "tex");
      __publicField(this, "frames", [new he(0, 0, 1, 1)]);
      __publicField(this, "anims", {});
      __publicField(this, "slice9", null);
      this.tex = i, u && (this.frames = u), this.anims = m, this.slice9 = f;
    }
    get width() {
      return this.tex.width * this.frames[0].w;
    }
    get height() {
      return this.tex.height * this.frames[0].h;
    }
    static from(i, u = {}) {
      return typeof i == "string" ? _j.fromURL(i, u) : Promise.resolve(_j.fromImage(i, u));
    }
    static fromImage(i, u = {}) {
      let [m, f] = N.packer.add(i), w = u.frames ? u.frames.map((x) => new he(f.x + x.x * f.w, f.y + x.y * f.h, x.w * f.w, x.h * f.h)) : we(u.sliceX || 1, u.sliceY || 1, f.x, f.y, f.w, f.h);
      return new _j(m, w, u.anims, u.slice9);
    }
    static fromURL(i, u = {}) {
      return Zt(i).then((m) => _j.fromImage(m, u));
    }
  };
  o(_j, "SpriteData");
  let j = _j;
  const _H = class _H {
    constructor(i) {
      __publicField(this, "buf");
      this.buf = i;
    }
    static fromArrayBuffer(i) {
      return new Promise((u, m) => Q.ctx.decodeAudioData(i, u, m)).then((u) => new _H(u));
    }
    static fromURL(i) {
      return yr(i) ? _H.fromArrayBuffer(Eo(i)) : Bo(i).then((u) => _H.fromArrayBuffer(u));
    }
  };
  o(_H, "SoundData");
  let H = _H;
  let Q = (() => {
    let r = new (window.AudioContext || window.webkitAudioContext)(), i = r.createGain();
    i.connect(r.destination);
    let u = new H(Ca(r));
    return r.decodeAudioData(ws.buffer.slice(0)).then((m) => {
      u.buf = m;
    }).catch((m) => {
      console.error("Failed to load burp: ", m);
    }), { ctx: r, masterNode: i, burpSnd: u };
  })(), N = { urlPrefix: "", sprites: new ut(), fonts: new ut(), bitmapFonts: new ut(), sounds: new ut(), shaders: new ut(), custom: new ut(), music: {}, packer: new nn(P, 2048, 2048), loaded: false };
  function J(r) {
    return typeof r != "string" || yr(r) ? r : N.urlPrefix + r;
  }
  o(J, "fixURL");
  let A = { events: new at(), objEvents: new at(), root: Yn([]), gravity: null, scenes: {}, currentScene: null, layers: null, defaultLayerIndex: 0, logs: [], cam: { pos: null, scale: new B(1), angle: 0, shake: 0, transform: new Le() } };
  A.root.use(Mn());
  function te(r) {
    return N.custom.add(null, r);
  }
  o(te, "load");
  function W() {
    let r = [N.sprites, N.sounds, N.shaders, N.fonts, N.bitmapFonts, N.custom];
    return r.reduce((i, u) => i + u.progress(), 0) / r.length;
  }
  o(W, "loadProgress");
  function se(r) {
    return r !== void 0 && (N.urlPrefix = r), N.urlPrefix;
  }
  o(se, "loadRoot");
  function ne(r, i) {
    return N.custom.add(r, Jt(i));
  }
  o(ne, "loadJSON");
  function ae(r, i, u = {}) {
    let m = new FontFace(r, typeof i == "string" ? `url(${i})` : i);
    return document.fonts.add(m), N.fonts.add(r, m.load().catch((f) => {
      throw new Error(`Failed to load font from "${i}": ${f}`);
    }).then((f) => new Rt(f, u)));
  }
  o(ae, "loadFont");
  function le(r, i, u, m, f = {}) {
    return N.bitmapFonts.add(r, Zt(i).then((w) => _n(Xe.fromImage(P, w, f), u, m, f.chars ?? Er)));
  }
  o(le, "loadBitmapFont");
  function we(r = 1, i = 1, u = 0, m = 0, f = 1, w = 1) {
    let x = [], R = f / r, O = w / i;
    for (let g = 0; g < i; g++) for (let C = 0; C < r; C++) x.push(new he(u + C * R, m + g * O, R, O));
    return x;
  }
  o(we, "slice");
  function be(r, i) {
    return r = J(r), te(typeof i == "string" ? new Promise((u, m) => {
      Jt(i).then((f) => {
        be(r, f).then(u).catch(m);
      });
    }) : j.from(r).then((u) => {
      let m = {};
      for (let f in i) {
        let w = i[f], x = u.frames[0], R = 2048 * x.w, O = 2048 * x.h, g = w.frames ? w.frames.map((L) => new he(x.x + (w.x + L.x) / R * x.w, x.y + (w.y + L.y) / O * x.h, L.w / R * x.w, L.h / O * x.h)) : we(w.sliceX || 1, w.sliceY || 1, x.x + w.x / R * x.w, x.y + w.y / O * x.h, w.width / R * x.w, w.height / O * x.h), C = new j(u.tex, g, w.anims);
        N.sprites.addLoaded(f, C), m[f] = C;
      }
      return m;
    }));
  }
  o(be, "loadSpriteAtlas");
  function Oe(r, i = {}) {
    let u = document.createElement("canvas"), m = r[0].width, f = r[0].height;
    u.width = m * r.length, u.height = f;
    let w = u.getContext("2d");
    r.forEach((R, O) => {
      R instanceof ImageData ? w.putImageData(R, O * m, 0) : w.drawImage(R, O * m, 0);
    });
    let x = w.getImageData(0, 0, r.length * m, f);
    return j.fromImage(x, { ...i, sliceX: r.length, sliceY: 1 });
  }
  o(Oe, "createSpriteSheet");
  function ye(r, i, u = { sliceX: 1, sliceY: 1, anims: {} }) {
    return i = J(i), Array.isArray(i) ? i.some((m) => typeof m == "string") ? N.sprites.add(r, Promise.all(i.map((m) => typeof m == "string" ? Zt(m) : Promise.resolve(m))).then((m) => Oe(m, u))) : N.sprites.addLoaded(r, Oe(i, u)) : typeof i == "string" ? N.sprites.add(r, j.from(i, u)) : N.sprites.addLoaded(r, j.fromImage(i, u));
  }
  o(ye, "loadSprite");
  function Ke(r, i) {
    return i = J(i), N.sprites.add(r, new Promise(async (u) => {
      let m = typeof i == "string" ? await Jt(i) : i, f = await Promise.all(m.frames.map(Zt)), w = document.createElement("canvas");
      w.width = m.width, w.height = m.height * m.frames.length;
      let x = w.getContext("2d");
      f.forEach((O, g) => {
        x.drawImage(O, 0, g * m.height);
      });
      let R = await ye(null, w, { sliceY: m.frames.length, anims: m.anims });
      u(R);
    }));
  }
  o(Ke, "loadPedit");
  function qe(r, i, u) {
    i = J(i), u = J(u), typeof i == "string" && !u && (u = Ao(i) + ".json");
    let m = typeof u == "string" ? Jt(u) : Promise.resolve(u);
    return N.sprites.add(r, m.then((f) => {
      let w = f.meta.size, x = f.frames.map((O) => new he(O.frame.x / w.w, O.frame.y / w.h, O.frame.w / w.w, O.frame.h / w.h)), R = {};
      for (let O of f.meta.frameTags) O.from === O.to ? R[O.name] = O.from : R[O.name] = { from: O.from, to: O.to, speed: 10, loop: true, pingpong: O.direction === "pingpong" };
      return j.from(i, { frames: x, anims: R });
    }));
  }
  o(qe, "loadAseprite");
  function ze(r, i, u) {
    return N.shaders.addLoaded(r, jt(i, u));
  }
  o(ze, "loadShader");
  function We(r, i, u) {
    i = J(i), u = J(u);
    let m = o((w) => w ? Mo(w) : Promise.resolve(null), "resolveUrl"), f = Promise.all([m(i), m(u)]).then(([w, x]) => jt(w, x));
    return N.shaders.add(r, f);
  }
  o(We, "loadShaderURL");
  function ft(r, i) {
    return i = J(i), N.sounds.add(r, typeof i == "string" ? H.fromURL(i) : H.fromArrayBuffer(i));
  }
  o(ft, "loadSound");
  function Ae(r, i) {
    let u = new Audio(i);
    return u.preload = "auto", N.music[r] = J(i);
  }
  o(Ae, "loadMusic");
  function Ue(r = "bean") {
    return ye(r, vs);
  }
  o(Ue, "loadBean");
  function Ne(r) {
    return N.sprites.get(r);
  }
  o(Ne, "getSprite");
  function ct(r) {
    return N.sounds.get(r);
  }
  o(ct, "getSound");
  function Ye(r) {
    return N.fonts.get(r);
  }
  o(Ye, "getFont");
  function Vt(r) {
    return N.bitmapFonts.get(r);
  }
  o(Vt, "getBitmapFont");
  function un(r) {
    return N.shaders.get(r);
  }
  o(un, "getShader");
  function Fn(r) {
    return N.custom.get(r);
  }
  o(Fn, "getAsset");
  function cn(r) {
    if (typeof r == "string") {
      let i = Ne(r);
      if (i) return i;
      if (W() < 1) return null;
      throw new Error(`Sprite not found: ${r}`);
    } else {
      if (r instanceof j) return Ve.loaded(r);
      if (r instanceof Ve) return r;
      throw new Error(`Invalid sprite: ${r}`);
    }
  }
  o(cn, "resolveSprite");
  function In(r) {
    if (typeof r == "string") {
      let i = ct(r);
      if (i) return i;
      if (W() < 1) return null;
      throw new Error(`Sound not found: ${r}`);
    } else {
      if (r instanceof H) return Ve.loaded(r);
      if (r instanceof Ve) return r;
      throw new Error(`Invalid sound: ${r}`);
    }
  }
  o(In, "resolveSound");
  function Ln(r) {
    if (!r) return v.defShader;
    if (typeof r == "string") {
      let i = un(r);
      if (i) return i.data ?? i;
      if (W() < 1) return null;
      throw new Error(`Shader not found: ${r}`);
    } else if (r instanceof Ve) return r.data ? r.data : r;
    return r;
  }
  o(Ln, "resolveShader");
  function ln(r) {
    if (!r) return ln(t.font ?? Go);
    if (typeof r == "string") {
      let i = Vt(r), u = Ye(r);
      if (i) return i.data ?? i;
      if (u) return u.data ?? u;
      if (document.fonts.check(`${64}px ${r}`)) return r;
      if (W() < 1) return null;
      throw new Error(`Font not found: ${r}`);
    } else if (r instanceof Ve) return r.data ? r.data : r;
    return r;
  }
  o(ln, "resolveFont");
  function jn(r) {
    return r !== void 0 && (Q.masterNode.gain.value = r), Q.masterNode.gain.value;
  }
  o(jn, "volume");
  function kn(r, i = {}) {
    let u = new Se(), m = new Audio(r);
    Q.ctx.createMediaElementSource(m).connect(Q.masterNode);
    function w() {
      de.paused || l.isHidden() && !t.backgroundAudio || Q.ctx.resume();
    }
    o(w, "resumeAudioCtx");
    function x() {
      w(), m.play();
    }
    return o(x, "play"), i.paused || x(), m.onended = () => u.trigger(), { play() {
      x();
    }, seek(R) {
      m.currentTime = R;
    }, stop() {
      m.pause(), this.seek(0);
    }, set loop(R) {
      m.loop = R;
    }, get loop() {
      return m.loop;
    }, set paused(R) {
      R ? m.pause() : x();
    }, get paused() {
      return m.paused;
    }, time() {
      return m.currentTime;
    }, duration() {
      return m.duration;
    }, set volume(R) {
      m.volume = tt(R, 0, 1);
    }, get volume() {
      return m.volume;
    }, set speed(R) {
      m.playbackRate = Math.max(R, 0);
    }, get speed() {
      return m.playbackRate;
    }, set detune(R) {
    }, get detune() {
      return 0;
    }, onEnd(R) {
      return u.add(R);
    }, then(R) {
      return this.onEnd(R);
    } };
  }
  o(kn, "playMusic");
  function mn(r, i = {}) {
    if (typeof r == "string" && N.music[r]) return kn(N.music[r], i);
    let u = Q.ctx, m = i.paused ?? false, f = u.createBufferSource(), w = new Se(), x = u.createGain(), R = i.seek ?? 0, O = 0, g = 0, C = false;
    f.loop = !!i.loop, f.detune.value = i.detune ?? 0, f.playbackRate.value = i.speed ?? 1, f.connect(x), f.onended = () => {
      var _a29;
      I() >= (((_a29 = f.buffer) == null ? void 0 : _a29.duration) ?? Number.POSITIVE_INFINITY) && w.trigger();
    }, x.connect(Q.masterNode), x.gain.value = i.volume ?? 1;
    let L = o((F) => {
      f.buffer = F.buf, m || (O = u.currentTime, f.start(0, R), C = true);
    }, "start"), U = In(r);
    U instanceof Ve && U.onLoad(L);
    let I = o(() => {
      if (!f.buffer) return 0;
      let F = m ? g - O : u.currentTime - O, V = f.buffer.duration;
      return f.loop ? F % V : Math.min(F, V);
    }, "getTime"), S = o((F) => {
      let V = u.createBufferSource();
      return V.buffer = F.buffer, V.loop = F.loop, V.playbackRate.value = F.playbackRate.value, V.detune.value = F.detune.value, V.onended = F.onended, V.connect(x), V;
    }, "cloneNode");
    return { stop() {
      this.paused = true, this.seek(0);
    }, set paused(F) {
      if (m !== F) if (m = F, F) C && (f.stop(), C = false), g = u.currentTime;
      else {
        f = S(f);
        let V = g - O;
        f.start(0, V), C = true, O = u.currentTime - V, g = 0;
      }
    }, get paused() {
      return m;
    }, play(F = 0) {
      this.seek(F), this.paused = false;
    }, seek(F) {
      var _a29;
      ((_a29 = f.buffer) == null ? void 0 : _a29.duration) && (F > f.buffer.duration || (m ? (f = S(f), O = g - F) : (f.stop(), f = S(f), O = u.currentTime - F, f.start(0, F), C = true, g = 0)));
    }, set speed(F) {
      f.playbackRate.value = F;
    }, get speed() {
      return f.playbackRate.value;
    }, set detune(F) {
      f.detune.value = F;
    }, get detune() {
      return f.detune.value;
    }, set volume(F) {
      x.gain.value = Math.max(F, 0);
    }, get volume() {
      return x.gain.value;
    }, set loop(F) {
      f.loop = F;
    }, get loop() {
      return f.loop;
    }, duration() {
      var _a29;
      return ((_a29 = f.buffer) == null ? void 0 : _a29.duration) ?? 0;
    }, time() {
      return I() % this.duration();
    }, onEnd(F) {
      return w.add(F);
    }, then(F) {
      return this.onEnd(F);
    } };
  }
  o(mn, "play");
  function dn(r) {
    return mn(Q.burpSnd, r);
  }
  o(dn, "burp");
  function Nn(r, i) {
    let u = new At(P, r, i);
    return { clear: o(() => u.clear(), "clear"), free: o(() => u.free(), "free"), toDataURL: o(() => u.toDataURL(), "toDataURL"), toImageData: o(() => u.toImageData(), "toImageData"), width: u.width, height: u.height, draw: o((m) => {
      De(), u.bind(), m(), De(), u.unbind();
    }, "draw") };
  }
  o(Nn, "makeCanvas");
  function jt(r = Rn, i = Pn) {
    let u = jo.replace("{{user}}", r ?? Rn), m = ko.replace("{{user}}", i ?? Pn);
    try {
      return new En(P, u, m, An.map((f) => f.name));
    } catch (f) {
      let x = /(?<type>^\w+) SHADER ERROR: 0:(?<line>\d+): (?<msg>.+)/, R = Po(f).match(x), O = Number(R.groups.line) - 14, g = R.groups.msg.trim(), C = R.groups.type.toLowerCase();
      throw new Error(`${C} shader line ${O}: ${g}`);
    }
  }
  o(jt, "makeShader");
  function _n(r, i, u, m) {
    let f = r.width / i, w = {}, x = m.split("").entries();
    for (let [R, O] of x) w[O] = new he(R % f * i, Math.floor(R / f) * u, i, u);
    return { tex: r, map: w, size: u };
  }
  o(_n, "makeFont");
  function lt(r, i, u, m = v.defTex, f = v.defShader, w = {}) {
    let x = Ln(f);
    if (!x || x instanceof Ve) return;
    let R = v.fixed || u ? v.transform : A.cam.transform.mult(v.transform), O = [];
    for (let g of r) {
      let C = Kn(R.multVec2(g.pos));
      O.push(C.x, C.y, g.uv.x, g.uv.y, g.color.r / 255, g.color.g / 255, g.color.b / 255, g.opacity);
    }
    v.renderer.push(y.TRIANGLES, O, i, x, m, w);
  }
  o(lt, "drawRaw");
  function De() {
    v.renderer.flush();
  }
  o(De, "flush");
  function kt() {
    y.clear(y.COLOR_BUFFER_BIT), v.frameBuffer.bind(), y.clear(y.COLOR_BUFFER_BIT), v.bgColor || me(() => {
      bt({ width: Re(), height: Fe(), quad: new he(0, 0, Re() / 64, Fe() / 64), tex: v.bgTex, fixed: true });
    }), v.renderer.numDraws = 0, v.fixed = false, v.transformStack.length = 0, v.transform = new Le();
  }
  o(kt, "frameStart");
  function Hn(r, i) {
    v.postShader = r, v.postShaderUniform = i ?? null;
  }
  o(Hn, "usePostEffect");
  function Nt() {
    De(), v.lastDrawCalls = v.renderer.numDraws, v.frameBuffer.unbind(), y.viewport(0, 0, y.drawingBufferWidth, y.drawingBufferHeight);
    let r = v.width, i = v.height;
    v.width = y.drawingBufferWidth / h, v.height = y.drawingBufferHeight / h, _t({ flipY: true, tex: v.frameBuffer.tex, pos: new B(v.viewport.x, v.viewport.y), width: v.viewport.width, height: v.viewport.height, shader: v.postShader, uniform: typeof v.postShaderUniform == "function" ? v.postShaderUniform() : v.postShaderUniform, fixed: true }), De(), v.width = r, v.height = i;
  }
  o(Nt, "frameEnd");
  function Kn(r) {
    return new B(r.x / Re() * 2 - 1, -r.y / Fe() * 2 + 1);
  }
  o(Kn, "screen2ndc");
  function qn(r) {
    v.transform = r.clone();
  }
  o(qn, "pushMatrix");
  function pe(...r) {
    if (r[0] === void 0) return;
    let i = E(...r);
    i.x === 0 && i.y === 0 || v.transform.translate(i);
  }
  o(pe, "pushTranslate");
  function gt(...r) {
    if (r[0] === void 0) return;
    let i = E(...r);
    i.x === 1 && i.y === 1 || v.transform.scale(i);
  }
  o(gt, "pushScale");
  function mt(r) {
    r && v.transform.rotate(r);
  }
  o(mt, "pushRotate");
  function Me() {
    v.transformStack.push(v.transform.clone());
  }
  o(Me, "pushTransform");
  function Be() {
    v.transformStack.length > 0 && (v.transform = v.transformStack.pop());
  }
  o(Be, "popTransform");
  function bt(r) {
    if (r.width === void 0 || r.height === void 0) throw new Error('drawUVQuad() requires property "width" and "height".');
    if (r.width <= 0 || r.height <= 0) return;
    let i = r.width, u = r.height, f = Pt(r.anchor || It).scale(new B(i, u).scale(-0.5)), w = r.quad || new he(0, 0, 1, 1), x = r.color || ie(255, 255, 255), R = r.opacity ?? 1, O = r.tex ? 0.1 / r.tex.width : 0, g = r.tex ? 0.1 / r.tex.height : 0, C = w.x + O, L = w.y + g, U = w.w - O * 2, I = w.h - g * 2;
    Me(), pe(r.pos), mt(r.angle), gt(r.scale), pe(f), lt([{ pos: new B(-i / 2, u / 2), uv: new B(r.flipX ? C + U : C, r.flipY ? L : L + I), color: x, opacity: R }, { pos: new B(-i / 2, -u / 2), uv: new B(r.flipX ? C + U : C, r.flipY ? L + I : L), color: x, opacity: R }, { pos: new B(i / 2, -u / 2), uv: new B(r.flipX ? C : C + U, r.flipY ? L + I : L), color: x, opacity: R }, { pos: new B(i / 2, u / 2), uv: new B(r.flipX ? C : C + U, r.flipY ? L : L + I), color: x, opacity: R }], [0, 1, 3, 1, 2, 3], r.fixed, r.tex, r.shader, r.uniform), Be();
  }
  o(bt, "drawUVQuad");
  function _t(r) {
    if (!r.tex) throw new Error('drawTexture() requires property "tex".');
    let i = r.quad ?? new he(0, 0, 1, 1), u = r.tex.width * i.w, m = r.tex.height * i.h, f = new B(1);
    if (r.tiled) {
      let w = Math.ceil((r.width || u) / u), x = Math.ceil((r.height || m) / m), O = Pt(r.anchor || It).add(new B(1, 1)).scale(0.5).scale(w * u, x * m);
      for (let g = 0; g < w; g++) for (let C = 0; C < x; C++) bt(Object.assign({}, r, { pos: (r.pos || new B(0)).add(new B(u * g, m * C)).sub(O), scale: f.scale(r.scale || new B(1)), tex: r.tex, quad: i, width: u, height: m, anchor: "topleft" }));
    } else r.width && r.height ? (f.x = r.width / u, f.y = r.height / m) : r.width ? (f.x = r.width / u, f.y = f.x) : r.height && (f.y = r.height / m, f.x = f.y), bt(Object.assign({}, r, { scale: f.scale(r.scale || new B(1)), tex: r.tex, quad: i, width: u, height: m }));
  }
  o(_t, "drawTexture");
  function zn(r) {
    if (!r.sprite) throw new Error('drawSprite() requires property "sprite"');
    let i = cn(r.sprite);
    if (!i || !i.data) return;
    let u = i.data.frames[r.frame ?? 0];
    if (!u) throw new Error(`Frame not found: ${r.frame ?? 0}`);
    _t(Object.assign({}, r, { tex: i.data.tex, quad: u.scale(r.quad ?? new he(0, 0, 1, 1)) }));
  }
  o(zn, "drawSprite");
  function yt(r, i, u, m, f, w = 1) {
    m = ve(m % 360), f = ve(f % 360), f <= m && (f += Math.PI * 2);
    let x = [], R = Math.ceil((f - m) / ve(8) * w), O = (f - m) / R, g = E(Math.cos(m), Math.sin(m)), C = E(Math.cos(O), Math.sin(O));
    for (let L = 0; L <= R; L++) x.push(r.add(i * g.x, u * g.y)), g = E(g.x * C.x - g.y * C.y, g.x * C.y + g.y * C.x);
    return x;
  }
  o(yt, "getArcPts");
  function _e(r) {
    if (r.width === void 0 || r.height === void 0) throw new Error('drawRect() requires property "width" and "height".');
    if (r.width <= 0 || r.height <= 0) return;
    let i = r.width, u = r.height, f = Pt(r.anchor || It).add(1, 1).scale(new B(i, u).scale(-0.5)), w = [new B(0, 0), new B(i, 0), new B(i, u), new B(0, u)];
    if (r.radius) {
      let x = Math.min(i, u) / 2, R = Array.isArray(r.radius) ? r.radius.map((O) => Math.min(x, O)) : new Array(4).fill(Math.min(x, r.radius));
      w = [new B(R[0], 0), ...R[1] ? yt(new B(i - R[1], R[1]), R[1], R[1], 270, 360) : [E(i, 0)], ...R[2] ? yt(new B(i - R[2], u - R[2]), R[2], R[2], 0, 90) : [E(i, u)], ...R[3] ? yt(new B(R[3], u - R[3]), R[3], R[3], 90, 180) : [E(0, u)], ...R[0] ? yt(new B(R[0], R[0]), R[0], R[0], 180, 270) : []];
    }
    d(Object.assign({}, r, { offset: f, pts: w, ...r.gradient ? { colors: r.horizontal ? [r.gradient[0], r.gradient[1], r.gradient[1], r.gradient[0]] : [r.gradient[0], r.gradient[0], r.gradient[1], r.gradient[1]] } : {} }));
  }
  o(_e, "drawRect");
  function vt(r) {
    let { p1: i, p2: u } = r;
    if (!i || !u) throw new Error('drawLine() requires properties "p1" and "p2".');
    let m = r.width || 1, f = u.sub(i).unit().normal().scale(m * 0.5), w = [i.sub(f), i.add(f), u.add(f), u.sub(f)].map((x) => ({ pos: new B(x.x, x.y), uv: new B(0), color: r.color ?? oe.WHITE, opacity: r.opacity ?? 1 }));
    lt(w, [0, 1, 3, 1, 2, 3], r.fixed, v.defTex, r.shader, r.uniform);
  }
  o(vt, "drawLine");
  function Wn(r) {
    let i = r.pts, u = [], m = (r.width || 1) * 0.5, f = i[0] === i[i.length - 1] || i[0].eq(i[i.length - 1]), w = r.pos || E(0, 0), x;
    f ? x = i[0].sub(i[i.length - 2]) : x = i[1].sub(i[0]);
    let R = x.len(), O = x.normal().scale(-m / R), g, C = i[0];
    if (!f) switch (r.cap) {
      case "square": {
        let S = x.scale(-m / R);
        u.push(C.add(S).add(O)), u.push(C.add(S).sub(O));
        break;
      }
      case "round": {
        let S = Math.max(m, 10), F = Math.PI / S, V = O.scale(-1), X = Math.cos(F), q = Math.sin(F);
        for (let Y = 0; Y < S; Y++) u.push(C), u.push(C.sub(V)), V = E(V.x * X - V.y * q, V.x * q + V.y * X);
      }
    }
    for (let S = 1; S < i.length; S++) {
      if (C === i[S] || C.eq(i[S])) continue;
      g = C, C = i[S];
      let F = C.sub(g), V = F.len(), X = F.normal().scale(-m / V), q = x.cross(F);
      if (Math.abs(q) / (R * V) < 0.05) {
        u.push(g.add(O)), u.push(g.sub(O)), x.dot(F) < 0 && (u.push(g.sub(O)), u.push(g.add(O))), x = F, R = V, O = X;
        continue;
      }
      let Y = X.sub(O).cross(F) / q, z = O.add(x.scale(Y));
      q > 0 ? (u.push(g.add(z)), u.push(g.sub(O)), u.push(g.add(z)), u.push(g.sub(X))) : (u.push(g.add(O)), u.push(g.sub(z)), u.push(g.add(X)), u.push(g.sub(z))), x = F, R = V, O = X;
    }
    if (!f) switch (u.push(C.add(O)), u.push(C.sub(O)), r.cap) {
      case "square": {
        let S = x.scale(m / R);
        u.push(C.add(S).add(O)), u.push(C.add(S).sub(O));
        break;
      }
      case "round": {
        let S = Math.max(m, 10), F = Math.PI / S, V = O.scale(1), X = Math.cos(F), q = Math.sin(F);
        for (let Y = 0; Y < S; Y++) V = E(V.x * X - V.y * q, V.x * q + V.y * X), u.push(C), u.push(C.sub(V));
      }
    }
    if (u.length < 4) return;
    let L = u.map((S) => ({ pos: w.add(S), uv: E(), color: r.color || oe.WHITE, opacity: r.opacity ?? 1 })), U = [], I = 0;
    for (let S = 0; S < u.length - 2; S += 2) U[I++] = S + 1, U[I++] = S, U[I++] = S + 2, U[I++] = S + 2, U[I++] = S + 3, U[I++] = S + 1;
    f && (U[I++] = u.length - 1, U[I++] = u.length - 2, U[I++] = 0, U[I++] = 0, U[I++] = 1, U[I++] = u.length - 1), lt(L, U, r.fixed, v.defTex, r.shader, r.uniform);
  }
  o(Wn, "_drawLinesBevel");
  function Ee(r) {
    let i = r.pts, u = [], m = (r.width || 1) * 0.5, f = i[0] === i[i.length - 1] || i[0].eq(i[i.length - 1]), w = r.pos || E(0, 0), x;
    f ? x = i[0].sub(i[i.length - 2]) : x = i[1].sub(i[0]);
    let R = x.len(), O = x.normal().scale(-m / R), g, C = i[0];
    if (!f) switch (r.cap) {
      case "square": {
        let S = x.scale(-m / R);
        u.push(C.add(S).add(O)), u.push(C.add(S).sub(O));
        break;
      }
      case "round": {
        let S = Math.max(m, 10), F = Math.PI / S, V = O.scale(-1), X = Math.cos(F), q = Math.sin(F);
        for (let Y = 0; Y < S; Y++) u.push(C), u.push(C.sub(V)), V = E(V.x * X - V.y * q, V.x * q + V.y * X);
      }
    }
    for (let S = 1; S < i.length; S++) {
      if (C === i[S] || C.eq(i[S])) continue;
      g = C, C = i[S];
      let F = C.sub(g), V = F.len(), X = F.normal().scale(-m / V), q = x.cross(F);
      if (Math.abs(q) / (R * V) < 0.05) {
        u.push(g.add(O)), u.push(g.sub(O)), x.dot(F) < 0 && (u.push(g.sub(O)), u.push(g.add(O))), x = F, R = V, O = X;
        continue;
      }
      let Y = X.sub(O).cross(F) / q, z = O.add(x.scale(Y));
      if (q > 0) {
        let Ie = g.add(z), D = Math.max(m, 10), _ = ve(O.angleBetween(X) / D), k = O, K = Math.cos(_), Z = Math.sin(_);
        for (let ee = 0; ee < D; ee++) u.push(Ie), u.push(g.sub(k)), k = E(k.x * K - k.y * Z, k.x * Z + k.y * K);
      } else {
        let Ie = g.sub(z), D = Math.max(m, 10), _ = ve(O.angleBetween(X) / D), k = O, K = Math.cos(_), Z = Math.sin(_);
        for (let ee = 0; ee < D; ee++) u.push(g.add(k)), u.push(Ie), k = E(k.x * K - k.y * Z, k.x * Z + k.y * K);
      }
      x = F, R = V, O = X;
    }
    if (!f) switch (u.push(C.add(O)), u.push(C.sub(O)), r.cap) {
      case "square": {
        let S = x.scale(m / R);
        u.push(C.add(S).add(O)), u.push(C.add(S).sub(O));
        break;
      }
      case "round": {
        let S = Math.max(m, 10), F = Math.PI / S, V = O.scale(1), X = Math.cos(F), q = Math.sin(F);
        for (let Y = 0; Y < S; Y++) V = E(V.x * X - V.y * q, V.x * q + V.y * X), u.push(C), u.push(C.sub(V));
      }
    }
    if (u.length < 4) return;
    let L = u.map((S) => ({ pos: w.add(S), uv: E(), color: r.color || oe.WHITE, opacity: r.opacity ?? 1 })), U = [], I = 0;
    for (let S = 0; S < u.length - 2; S += 2) U[I++] = S + 1, U[I++] = S, U[I++] = S + 2, U[I++] = S + 2, U[I++] = S + 3, U[I++] = S + 1;
    f && (U[I++] = u.length - 1, U[I++] = u.length - 2, U[I++] = 0, U[I++] = 0, U[I++] = 1, U[I++] = u.length - 1), lt(L, U, r.fixed, v.defTex, r.shader, r.uniform);
  }
  o(Ee, "_drawLinesRound");
  function xt(r) {
    let i = r.pts, u = [], m = (r.width || 1) * 0.5, f = i[0] === i[i.length - 1] || i[0].eq(i[i.length - 1]), w = r.pos || E(0, 0), x;
    f ? x = i[0].sub(i[i.length - 2]) : x = i[1].sub(i[0]);
    let R = x.len(), O = x.normal().scale(-m / R), g, C = i[0];
    if (!f) switch (r.cap) {
      case "square": {
        let S = x.scale(-m / R);
        u.push(C.add(S).add(O)), u.push(C.add(S).sub(O));
        break;
      }
      case "round": {
        let S = Math.max(m, 10), F = Math.PI / S, V = O.scale(-1), X = Math.cos(F), q = Math.sin(F);
        for (let Y = 0; Y < S; Y++) u.push(C), u.push(C.sub(V)), V = E(V.x * X - V.y * q, V.x * q + V.y * X);
      }
    }
    for (let S = 1; S < i.length; S++) {
      if (C === i[S] || C.eq(i[S])) continue;
      g = C, C = i[S];
      let F = C.sub(g), V = F.len(), X = F.normal().scale(-m / V), q = x.cross(F);
      if (Math.abs(q) / (R * V) < 0.05) {
        u.push(g.add(O)), u.push(g.sub(O)), x.dot(F) < 0 && (u.push(g.sub(O)), u.push(g.add(O))), x = F, R = V, O = X;
        continue;
      }
      let Y = X.sub(O).cross(F) / q, z = O.add(x.scale(Y));
      u.push(g.add(z)), u.push(g.sub(z)), x = F, R = V, O = X;
    }
    if (!f) switch (u.push(C.add(O)), u.push(C.sub(O)), r.cap) {
      case "square": {
        let S = x.scale(m / R);
        u.push(C.add(S).add(O)), u.push(C.add(S).sub(O));
        break;
      }
      case "round": {
        let S = Math.max(m, 10), F = Math.PI / S, V = O.scale(1), X = Math.cos(F), q = Math.sin(F);
        for (let Y = 0; Y < S; Y++) V = E(V.x * X - V.y * q, V.x * q + V.y * X), u.push(C), u.push(C.sub(V));
      }
    }
    if (u.length < 4) return;
    let L = u.map((S) => ({ pos: w.add(S), uv: E(), color: r.color || oe.WHITE, opacity: r.opacity ?? 1 })), U = [], I = 0;
    for (let S = 0; S < u.length - 2; S += 2) U[I++] = S + 1, U[I++] = S, U[I++] = S + 2, U[I++] = S + 2, U[I++] = S + 3, U[I++] = S + 1;
    f && (U[I++] = u.length - 1, U[I++] = u.length - 2, U[I++] = 0, U[I++] = 0, U[I++] = 1, U[I++] = u.length - 1), lt(L, U, r.fixed, v.defTex, r.shader, r.uniform);
  }
  o(xt, "_drawLinesMiter");
  function et(r) {
    let i = r.pts;
    if (!i) throw new Error('drawLines() requires property "pts".');
    if (!(i.length < 2)) {
      if (i.length > 2) switch (r.join) {
        case "bevel":
          return Wn(r);
        case "round":
          return Ee(r);
        case "miter":
          return xt(r);
      }
      if (r.radius && i.length >= 3) {
        vt(Object.assign({}, r, { p1: i[0], p2: i[1] }));
        for (let u = 1; u < i.length - 2; u++) {
          let m = i[u], f = i[u + 1];
          vt(Object.assign({}, r, { p1: m, p2: f }));
        }
        vt(Object.assign({}, r, { p1: i[i.length - 2], p2: i[i.length - 1] }));
      } else for (let u = 0; u < i.length - 1; u++) vt(Object.assign({}, r, { p1: i[u], p2: i[u + 1] })), r.join !== "none" && Ut(Object.assign({}, r, { pos: i[u], radius: r.width / 2 }));
    }
  }
  o(et, "drawLines");
  function Ht(r, i) {
    let u = i.segments ?? 16, m = [];
    for (let f = 0; f <= u; f++) m.push(r(f / u));
    et({ pts: m, width: i.width || 1, pos: i.pos, color: i.color, opacity: i.opacity });
  }
  o(Ht, "drawCurve");
  function hn(r) {
    Ht((i) => wn(r.pt1, r.pt2, r.pt3, r.pt4, i), r);
  }
  o(hn, "drawBezier");
  function pn(r) {
    if (!r.p1 || !r.p2 || !r.p3) throw new Error('drawTriangle() requires properties "p1", "p2" and "p3".');
    return d(Object.assign({}, r, { pts: [r.p1, r.p2, r.p3] }));
  }
  o(pn, "drawTriangle");
  function Ut(r) {
    if (typeof r.radius != "number") throw new Error('drawCircle() requires property "radius".');
    r.radius !== 0 && Kt(Object.assign({}, r, { radiusX: r.radius, radiusY: r.radius, angle: 0 }));
  }
  o(Ut, "drawCircle");
  function Kt(r) {
    if (r.radiusX === void 0 || r.radiusY === void 0) throw new Error('drawEllipse() requires properties "radiusX" and "radiusY".');
    if (r.radiusX === 0 || r.radiusY === 0) return;
    let i = r.start ?? 0, u = r.end ?? 360, m = Pt(r.anchor ?? "center").scale(new B(-r.radiusX, -r.radiusY)), f = yt(m, r.radiusX, r.radiusY, i, u, r.resolution);
    f.unshift(m);
    let w = Object.assign({}, r, { pts: f, radius: 0, ...r.gradient ? { colors: [r.gradient[0], ...Array(f.length - 1).fill(r.gradient[1])] } : {} });
    if (u - i >= 360 && r.outline) {
      r.fill !== false && d(Object.assign({}, w, { outline: null })), d(Object.assign({}, w, { pts: f.slice(1), fill: false }));
      return;
    }
    d(w);
  }
  o(Kt, "drawEllipse");
  function d(r) {
    if (!r.pts) throw new Error('drawPolygon() requires property "pts".');
    let i = r.pts.length;
    if (!(i < 3)) {
      if (Me(), pe(r.pos), gt(r.scale), mt(r.angle), pe(r.offset), r.fill !== false) {
        let u = r.color ?? oe.WHITE, m = r.pts.map((w, x) => ({ pos: new B(w.x, w.y), uv: r.uv ? r.uv[x] : new B(0, 0), color: r.colors && r.colors[x] ? r.colors[x].mult(u) : u, opacity: r.opacity ?? 1 })), f;
        r.triangulate ? f = fr(r.pts).map((x) => x.map((R) => r.pts.indexOf(R))).flat() : f = [...Array(i - 2).keys()].map((w) => [0, w + 1, w + 2]).flat(), lt(m, r.indices ?? f, r.fixed, r.uv ? r.tex : v.defTex, r.shader, r.uniform);
      }
      r.outline && et({ pts: [...r.pts, r.pts[0]], radius: r.radius, width: r.outline.width, color: r.outline.color, join: r.outline.join, uniform: r.uniform, fixed: r.fixed, opacity: r.opacity ?? r.outline.opacity }), Be();
    }
  }
  o(d, "drawPolygon");
  function T(r, i, u) {
    De(), y.clear(y.STENCIL_BUFFER_BIT), y.enable(y.STENCIL_TEST), y.stencilFunc(y.NEVER, 1, 255), y.stencilOp(y.REPLACE, y.REPLACE, y.REPLACE), i(), De(), y.stencilFunc(u, 1, 255), y.stencilOp(y.KEEP, y.KEEP, y.KEEP), r(), De(), y.disable(y.STENCIL_TEST);
  }
  o(T, "drawStenciled");
  function G(r, i) {
    T(r, i, y.EQUAL);
  }
  o(G, "drawMasked");
  function $(r, i) {
    T(r, i, y.NOTEQUAL);
  }
  o($, "drawSubtracted");
  function Ce() {
    return (v.viewport.width + v.viewport.height) / (v.width + v.height);
  }
  o(Ce, "getViewportScale");
  function me(r) {
    De();
    let i = v.width, u = v.height;
    v.width = v.viewport.width, v.height = v.viewport.height, r(), De(), v.width = i, v.height = u;
  }
  o(me, "drawUnscaled");
  function fe(r, i) {
    i.pos && (r.pos = r.pos.add(i.pos)), i.scale && (r.scale = r.scale.scale(E(i.scale))), i.angle && (r.angle += i.angle), i.color && r.ch.length === 1 && (r.color = r.color.mult(i.color)), i.opacity && (r.opacity *= i.opacity);
  }
  o(fe, "applyCharTransform");
  function rt(r) {
    let i = {}, u = r.replace(Or, "$2"), m = 0;
    for (let f of r.matchAll(Or)) {
      let w = f.index - m;
      for (let x = 0; x < f.groups.text.length; x++) i[x + w] = [f.groups.style];
      m += f[0].length - f.groups.text.length;
    }
    return { charStyleMap: i, text: u };
  }
  o(rt, "compileStyledText");
  let $e = {};
  function Ge(r) {
    var _a29, _b;
    if (r.text === void 0) throw new Error('formatText() requires property "text".');
    let i = ln(r.font);
    if (r.text === "" || i instanceof Ve || !i) return { width: 0, height: 0, chars: [], opt: r };
    let { charStyleMap: u, text: m } = rt(r.text + ""), f = Vo(m);
    if (i instanceof Rt || typeof i == "string") {
      let q = i instanceof Rt ? i.fontface.family : i, Y = i instanceof Rt ? { outline: i.outline, filter: i.filter } : { outline: null, filter: tn }, z = $e[q] ?? { font: { tex: new Xe(P, 2048, 2048, { filter: Y.filter }), map: {}, size: 64 }, cursor: new B(0), outline: Y.outline };
      $e[q] || ($e[q] = z), i = z.font;
      for (let Ie of f) if (!z.font.map[Ie]) {
        let D = p;
        D.clearRect(0, 0, b.width, b.height), D.font = `${i.size}px ${q}`, D.textBaseline = "top", D.textAlign = "left", D.fillStyle = "#ffffff";
        let _ = D.measureText(Ie), k = Math.ceil(_.width);
        if (!k) continue;
        let K = i.size;
        z.outline && (D.lineJoin = "round", D.lineWidth = z.outline.width * 2, D.strokeStyle = z.outline.color.toHex(), D.strokeText(Ie, z.outline.width, z.outline.width), k += z.outline.width * 2, K += z.outline.width * 3), D.fillText(Ie, ((_a29 = z.outline) == null ? void 0 : _a29.width) ?? 0, ((_b = z.outline) == null ? void 0 : _b.width) ?? 0);
        let Z = D.getImageData(0, 0, k, K);
        if (z.cursor.x + k > 2048 && (z.cursor.x = 0, z.cursor.y += K, z.cursor.y > 2048)) throw new Error("Font atlas exceeds character limit");
        i.tex.update(Z, z.cursor.x, z.cursor.y), i.map[Ie] = new he(z.cursor.x, z.cursor.y, k, K), z.cursor.x += k;
      }
    }
    let w = r.size || i.size, x = E(r.scale ?? 1).scale(w / i.size), R = r.lineSpacing ?? 0, O = r.letterSpacing ?? 0, g = 0, C = 0, L = 0, U = [], I = [], S = 0, F = null, V = null;
    for (; S < f.length; ) {
      let q = f[S];
      if (q === `
`) L += w + R, U.push({ width: g - O, chars: I }), F = null, V = null, g = 0, I = [];
      else {
        let Y = i.map[q];
        if (Y) {
          let z = Y.w * x.x;
          r.width && g + z > r.width && (L += w + R, F != null && (S -= I.length - F, q = f[S], Y = i.map[q], z = Y.w * x.x, I = I.slice(0, F - 1), g = V), F = null, V = null, U.push({ width: g - O, chars: I }), g = 0, I = []), I.push({ tex: i.tex, width: Y.w, height: Y.h, quad: new he(Y.x / i.tex.width, Y.y / i.tex.height, Y.w / i.tex.width, Y.h / i.tex.height), ch: q, pos: new B(g, L), opacity: r.opacity ?? 1, color: r.color ?? oe.WHITE, scale: E(x), angle: 0 }), q === " " && (F = I.length, V = g), g += z, C = Math.max(C, g), g += O;
        }
      }
      S++;
    }
    U.push({ width: g - O, chars: I }), L += w, r.width && (C = r.width);
    let X = [];
    for (let q = 0; q < U.length; q++) {
      let Y = (C - U[q].width) * wa(r.align ?? "left");
      for (let z of U[q].chars) {
        let Ie = i.map[z.ch], D = X.length + q;
        if (z.pos = z.pos.add(Y, 0).add(Ie.w * x.x * 0.5, Ie.h * x.y * 0.5), r.transform) {
          let _ = typeof r.transform == "function" ? r.transform(D, z.ch) : r.transform;
          _ && fe(z, _);
        }
        if (u[D]) {
          let _ = u[D];
          for (let k of _) {
            let K = r.styles[k], Z = typeof K == "function" ? K(D, z.ch) : K;
            Z && fe(z, Z);
          }
        }
        X.push(z);
      }
    }
    return { width: C, height: L, chars: X, opt: r };
  }
  o(Ge, "formatText");
  function Dt(r) {
    Mt(Ge(r));
  }
  o(Dt, "drawText");
  function Mt(r) {
    Me(), pe(r.opt.pos), mt(r.opt.angle), pe(Pt(r.opt.anchor ?? "topleft").add(1, 1).scale(r.width, r.height).scale(-0.5)), r.chars.forEach((i) => {
      bt({ tex: i.tex, width: i.width, height: i.height, pos: i.pos, scale: i.scale, angle: i.angle, color: i.color, opacity: i.opacity, quad: i.quad, anchor: "center", uniform: r.opt.uniform, shader: r.opt.shader, fixed: r.opt.fixed });
    }), Be();
  }
  o(Mt, "drawFormattedText");
  function Re() {
    return v.width;
  }
  o(Re, "width");
  function Fe() {
    return v.height;
  }
  o(Fe, "height");
  function Ps() {
    return A.root;
  }
  o(Ps, "getTreeRoot");
  function Vs(r) {
    return new B((r.x - v.viewport.x) * Re() / v.viewport.width, (r.y - v.viewport.y) * Fe() / v.viewport.height);
  }
  o(Vs, "windowToContent");
  function Us(r) {
    return new B(r.x * v.viewport.width / v.width, r.y * v.viewport.height / v.height);
  }
  o(Us, "contentToView");
  function Mr() {
    return Vs(l.mousePos());
  }
  o(Mr, "mousePos");
  let Br = false, de = { inspect: false, timeScale: 1, showLog: true, fps: o(() => l.fps(), "fps"), numFrames: o(() => l.numFrames(), "numFrames"), stepFrame: _r, drawCalls: o(() => v.lastDrawCalls, "drawCalls"), clearLog: o(() => A.logs = [], "clearLog"), log: o((r) => {
    let i = t.logMax ?? 8;
    A.logs.unshift({ msg: r, time: l.time() }), A.logs.length > i && (A.logs = A.logs.slice(0, i));
  }, "log"), error: o((r) => de.log(new Error(r.toString ? r.toString() : r)), "error"), curRecording: null, numObjects: o(() => Jn("*", { recursive: true }).length, "numObjects"), get paused() {
    return Br;
  }, set paused(r) {
    Br = r, r ? Q.ctx.suspend() : Q.ctx.resume();
  } };
  function Xn() {
    return l.dt() * de.timeScale;
  }
  o(Xn, "dt");
  function Ds(...r) {
    return r.length > 0 && (A.cam.pos = E(...r)), A.cam.pos ? A.cam.pos.clone() : gn();
  }
  o(Ds, "camPos");
  function Ms(...r) {
    return r.length > 0 && (A.cam.scale = E(...r)), A.cam.scale.clone();
  }
  o(Ms, "camScale");
  function Bs(r) {
    return r !== void 0 && (A.cam.angle = r), A.cam.angle;
  }
  o(Bs, "camRot");
  function Gs(r = ie(255, 255, 255), i = 1) {
    let u = Bt([Pr(Re(), Fe()), Ar(r), Rr(1), Dr()]), m = u.fadeOut(i);
    return m.onEnd(() => kr(u)), m;
  }
  o(Gs, "camFlash");
  function Fs() {
    return A.cam.transform.clone();
  }
  o(Fs, "camTransform");
  function Is(r = 12) {
    A.cam.shake += r;
  }
  o(Is, "shake");
  function Ls(r) {
    return A.cam.transform.multVec2(r);
  }
  o(Ls, "toScreen");
  function js(r) {
    return A.cam.transform.invert().multVec2(r);
  }
  o(js, "toWorld");
  function Gr(r) {
    let i = new Le();
    return r.pos && i.translate(r.pos), r.scale && i.scale(r.scale), r.angle && i.rotate(r.angle), r.parent ? i.mult(r.parent.transform) : i;
  }
  o(Gr, "calcTransform");
  function Yn(r = []) {
    let i = /* @__PURE__ */ new Map(), u = {}, m = new at(), f = [], w = null, x = false, R = { id: Ro(), hidden: false, transform: new Le(), children: [], parent: null, set paused(g) {
      if (g !== x) {
        x = g;
        for (let C of f) C.paused = g;
      }
    }, get paused() {
      return x;
    }, get tags() {
      let g = [];
      for (let [C, L] of i.entries()) Object.keys(L).length == 1 && g.push(C);
      return g;
    }, add(g = []) {
      let C = Array.isArray(g) ? Yn(g) : g;
      if (C.parent) throw new Error("Cannot add a game obj that already has a parent.");
      return C.parent = this, C.transform = Gr(C), this.children.push(C), C.trigger("add", C), A.events.trigger("add", C), C;
    }, readd(g) {
      let C = this.children.indexOf(g);
      return C !== -1 && (this.children.splice(C, 1), this.children.push(g)), g;
    }, remove(g) {
      let C = this.children.indexOf(g);
      if (C !== -1) {
        g.parent = null, this.children.splice(C, 1);
        let L = o((U) => {
          U.trigger("destroy"), A.events.trigger("destroy", U), U.children.forEach((I) => L(I));
        }, "trigger");
        L(g);
      }
    }, removeAll(g) {
      if (g) this.get(g).forEach((C) => this.remove(C));
      else for (let C of [...this.children]) this.remove(C);
    }, update() {
      this.paused || (this.children.forEach((g) => g.update()), this.trigger("update"));
    }, draw() {
      if (this.hidden) return;
      this.canvas && (De(), this.canvas.bind());
      let g = v.fixed;
      this.fixed && (v.fixed = true), Me(), pe(this.pos), gt(this.scale), mt(this.angle);
      let C = this.children.sort((L, U) => {
        let I = L.layerIndex ?? A.defaultLayerIndex, S = U.layerIndex ?? A.defaultLayerIndex;
        return I - S || (L.z ?? 0) - (U.z ?? 0);
      });
      if (this.mask) {
        let L = { intersect: G, subtract: $ }[this.mask];
        if (!L) throw new Error(`Invalid mask func: "${this.mask}"`);
        L(() => {
          C.forEach((U) => U.draw());
        }, () => {
          this.trigger("draw");
        });
      } else this.trigger("draw"), C.forEach((L) => L.draw());
      Be(), v.fixed = g, this.canvas && (De(), this.canvas.unbind());
    }, drawInspect() {
      this.hidden || (Me(), pe(this.pos), gt(this.scale), mt(this.angle), this.children.forEach((g) => g.drawInspect()), this.trigger("drawInspect"), Be());
    }, use(g) {
      if (!g) return;
      if (Uo(g) && (g = new g(this)), typeof g == "function") return this.use(g(this));
      if (typeof g == "string") return this.use({ id: g });
      let C = [];
      g.id && (this.unuse(g.id), u[g.id] = [], C = u[g.id], i.set(g.id, g));
      for (let U in g) {
        if (No.has(U)) continue;
        let I = Object.getOwnPropertyDescriptor(g, U);
        if (typeof I.value == "function" && (g[U] = g[U].bind(this)), I.set && Object.defineProperty(g, U, { set: I.set.bind(this) }), I.get && Object.defineProperty(g, U, { get: I.get.bind(this) }), _o.has(U)) {
          let S = U === "add" ? () => {
            w = o((F) => C.push(F), "onCurCompCleanup"), g[U](), w = null;
          } : g[U];
          C.push(this.on(U, S).cancel);
        } else if (this[U] === void 0) Object.defineProperty(this, U, { get: o(() => g[U], "get"), set: o((S) => g[U] = S, "set"), configurable: true, enumerable: true }), C.push(() => delete this[U]);
        else throw new Error(`Duplicate component property: "${U}"`);
      }
      let L = o(() => {
        if (g.require) {
          for (let U of g.require) if (!this.c(U)) throw new Error(`Component "${g.id}" requires component "${U}"`);
        }
      }, "checkDeps");
      g.destroy && C.push(g.destroy.bind(this)), this.exists() ? (L(), g.add && (w = o((U) => C.push(U), "onCurCompCleanup"), g.add.call(this), w = null)) : g.require && C.push(this.on("add", L).cancel);
    }, unuse(g) {
      u[g] && (u[g].forEach((C) => C()), delete u[g]), i.has(g) && i.delete(g);
    }, c(g) {
      return i.get(g);
    }, get(g, C = {}) {
      let L = C.recursive ? this.children.flatMap(o(function U(I) {
        return [I, ...I.children.flatMap(U)];
      }, "recurse")) : this.children;
      if (L = L.filter((U) => g ? U.is(g) : true), C.liveUpdate) {
        let U = o((S) => C.recursive ? this.isAncestorOf(S) : S.parent === this, "isChild"), I = [];
        I.push($n((S) => {
          U(S) && S.is(g) && L.push(S);
        })), I.push(Fr((S) => {
          if (U(S) && S.is(g)) {
            let F = L.findIndex((V) => V.id === S.id);
            F !== -1 && L.splice(F, 1);
          }
        })), this.onDestroy(() => {
          for (let S of I) S.cancel();
        });
      }
      return L;
    }, query(g) {
      let C = g.hierarchy || "children", L = [];
      switch (C) {
        case "children":
          L = this.children;
          break;
        case "siblings":
          L = this.parent ? this.parent.children.filter((I) => I !== this) : [];
          break;
        case "ancestors":
          let U = this.parent;
          for (; U; ) L.push(U), U = U.parent;
          break;
        case "descendants":
          L = this.children.flatMap(o(function I(S) {
            return [S, ...S.children.flatMap(I)];
          }, "recurse"));
          break;
      }
      if (g.include && ((g.includeOp || "and") === "and" || !Array.isArray(g.include) ? L = L.filter((I) => I.is(g.include)) : L = L.filter((I) => g.include.some((S) => I.is(S)))), g.exclude && ((g.includeOp || "and") === "and" || !Array.isArray(g.include) ? L = L.filter((I) => !I.is(g.exclude)) : L = L.filter((I) => !g.exclude.some((S) => I.is(S)))), g.visible === true && (L = L.filter((U) => U.visible)), g.distance) {
        if (!this.pos) throw Error("Can't do a distance query from an object without pos");
        let U = g.distanceOp || "near", I = g.distance * g.distance;
        U === "near" ? L = L.filter((S) => S.pos && this.pos.sdist(S.pos) <= I) : L = L.filter((S) => S.pos && this.pos.sdist(S.pos) > I);
      }
      return g.name && (L = L.filter((U) => U.name === g.name)), L;
    }, isAncestorOf(g) {
      return g.parent ? g.parent === this || this.isAncestorOf(g.parent) : false;
    }, exists() {
      return A.root.isAncestorOf(this);
    }, is(g) {
      if (g === "*") return true;
      if (Array.isArray(g)) {
        for (let C of g) if (!this.c(C)) return false;
        return true;
      } else return this.c(g) != null;
    }, on(g, C) {
      let L = m.on(g, C.bind(this));
      return w && w(() => L.cancel()), L;
    }, trigger(g, ...C) {
      m.trigger(g, ...C), A.objEvents.trigger(g, this, ...C);
    }, destroy() {
      this.parent && this.parent.remove(this);
    }, inspect() {
      let g = {};
      for (let [C, L] of i) g[C] = L.inspect ? L.inspect() : null;
      return g;
    }, onAdd(g) {
      return this.on("add", g);
    }, onUpdate(g) {
      return this.on("update", g);
    }, onDraw(g) {
      return this.on("draw", g);
    }, onDestroy(g) {
      return this.on("destroy", g);
    }, clearEvents() {
      m.clear();
    } }, O = ["onKeyPress", "onKeyPressRepeat", "onKeyDown", "onKeyRelease", "onMousePress", "onMouseDown", "onMouseRelease", "onMouseMove", "onCharInput", "onMouseMove", "onTouchStart", "onTouchMove", "onTouchEnd", "onScroll", "onGamepadButtonPress", "onGamepadButtonDown", "onGamepadButtonRelease", "onGamepadStick", "onButtonPress", "onButtonDown", "onButtonRelease"];
    for (let g of O) R[g] = (...C) => {
      var _a29;
      let L = (_a29 = l[g]) == null ? void 0 : _a29.call(l, ...C);
      return f.push(L), R.onDestroy(() => L.cancel()), L;
    };
    for (let g of r) R.use(g);
    return R;
  }
  o(Yn, "make");
  function dt(r, i, u) {
    return A.objEvents[r] || (A.objEvents[r] = new Qt()), A.objEvents.on(r, (m, ...f) => {
      m.is(i) && u(m, ...f);
    });
  }
  o(dt, "on");
  let ks = xe((r) => {
    let i = Bt([{ update: r }]);
    return { get paused() {
      return i.paused;
    }, set paused(u) {
      i.paused = u;
    }, cancel: o(() => i.destroy(), "cancel") };
  }, (r, i) => dt("update", r, i)), Ns = xe((r) => {
    let i = Bt([{ draw: r }]);
    return { get paused() {
      return i.hidden;
    }, set paused(u) {
      i.hidden = u;
    }, cancel: o(() => i.destroy(), "cancel") };
  }, (r, i) => dt("draw", r, i)), $n = xe((r) => A.events.on("add", r), (r, i) => dt("add", r, i)), Fr = xe((r) => A.events.on("destroy", r), (r, i) => dt("destroy", r, i));
  function _s(r, i, u) {
    return dt("collide", r, (m, f, w) => f.is(i) && u(m, f, w));
  }
  o(_s, "onCollide");
  function Hs(r, i, u) {
    return dt("collideUpdate", r, (m, f, w) => f.is(i) && u(m, f, w));
  }
  o(Hs, "onCollideUpdate");
  function Ks(r, i, u) {
    return dt("collideEnd", r, (m, f, w) => f.is(i) && u(m, f, w));
  }
  o(Ks, "onCollideEnd");
  function fn(r, i) {
    Jn(r, { recursive: true }).forEach(i), $n(r, i);
  }
  o(fn, "forAllCurrentAndFuture");
  let qs = xe((r) => l.onMousePress(r), (r, i) => {
    let u = [];
    return fn(r, (m) => {
      if (!m.area) throw new Error("onClick() requires the object to have area() component");
      u.push(m.onClick(() => i(m)));
    }), it.join(u);
  });
  function zs(r, i) {
    let u = [];
    return fn(r, (m) => {
      if (!m.area) throw new Error("onHover() requires the object to have area() component");
      u.push(m.onHover(() => i(m)));
    }), it.join(u);
  }
  o(zs, "onHover");
  function Ws(r, i) {
    let u = [];
    return fn(r, (m) => {
      if (!m.area) throw new Error("onHoverUpdate() requires the object to have area() component");
      u.push(m.onHoverUpdate(() => i(m)));
    }), it.join(u);
  }
  o(Ws, "onHoverUpdate");
  function Xs(r, i) {
    let u = [];
    return fn(r, (m) => {
      if (!m.area) throw new Error("onHoverEnd() requires the object to have area() component");
      u.push(m.onHoverEnd(() => i(m)));
    }), it.join(u);
  }
  o(Xs, "onHoverEnd");
  function Ys(r) {
    A.gravity = r ? (A.gravity || E(0, 1)).unit().scale(r) : null;
  }
  o(Ys, "setGravity");
  function $s() {
    return A.gravity ? A.gravity.len() : 0;
  }
  o($s, "getGravity");
  function Qs(r) {
    A.gravity = r.unit().scale(A.gravity ? A.gravity.len() : 1);
  }
  o(Qs, "setGravityDirection");
  function Js() {
    return A.gravity ? A.gravity.unit() : E(0, 1);
  }
  o(Js, "getGravityDirection");
  function Zs(...r) {
    r.length === 1 || r.length === 2 ? (v.bgColor = ie(r[0]), r[1] && (v.bgAlpha = r[1])) : (r.length === 3 || r.length === 4) && (v.bgColor = ie(r[0], r[1], r[2]), r[3] && (v.bgAlpha = r[3])), y.clearColor(v.bgColor.r / 255, v.bgColor.g / 255, v.bgColor.b / 255, v.bgAlpha);
  }
  o(Zs, "setBackground");
  function ei() {
    return v.bgColor.clone();
  }
  o(ei, "getBackground");
  function Qn(r, i) {
    return Number(r.toFixed(i));
  }
  o(Qn, "toFixed");
  function Ir(r) {
    return r.fixed ? true : r.parent ? Ir(r.parent) : false;
  }
  o(Ir, "isFixed");
  function ti(r) {
    return { color: r.color, opacity: r.opacity, anchor: r.anchor, outline: r.outline, shader: r.shader, uniform: r.uniform };
  }
  o(ti, "getRenderProps");
  function ni(r) {
    N.loaded ? r() : A.events.on("load", r);
  }
  o(ni, "onLoad");
  function ri(r, i) {
    A.scenes[r] = i;
  }
  o(ri, "scene");
  function oi(r, ...i) {
    if (!A.scenes[r]) throw new Error(`Scene not found: ${r}`);
    A.events.onOnce("frameEnd", () => {
      A.events.trigger("sceneLeave", r), l.events.clear(), A.events.clear(), A.objEvents.clear(), [...A.root.children].forEach((u) => {
        (!u.stay || u.scenesToStay && !u.scenesToStay.includes(r)) && A.root.remove(u);
      }), A.root.clearEvents(), qr(), A.cam = { pos: null, scale: E(1), angle: 0, shake: 0, transform: new Le() }, A.scenes[r](...i);
    }), A.currentScene = r;
  }
  o(oi, "go");
  function si(r) {
    return A.events.on("sceneLeave", r);
  }
  o(si, "onSceneLeave");
  function ii() {
    return A.currentScene;
  }
  o(ii, "getSceneName");
  function ai(r, i) {
    try {
      return JSON.parse(window.localStorage[r]);
    } catch {
      return i ? (Lr(r, i), i) : null;
    }
  }
  o(ai, "getData");
  function Lr(r, i) {
    window.localStorage[r] = JSON.stringify(i);
  }
  o(Lr, "setData");
  function jr(r, ...i) {
    let u = r(Ze), m;
    typeof u == "function" ? m = u(...i)(Ze) : m = u;
    for (let f in m) Ze[f] = m[f], t.global !== false && (window[f] = m[f]);
    return Ze;
  }
  o(jr, "plug");
  function gn() {
    return E(Re() / 2, Fe() / 2);
  }
  o(gn, "center");
  let ui;
  ((V) => (V[V.None = 0] = "None", V[V.Left = 1] = "Left", V[V.Top = 2] = "Top", V[V.LeftTop = 3] = "LeftTop", V[V.Right = 4] = "Right", V[V.Horizontal = 5] = "Horizontal", V[V.RightTop = 6] = "RightTop", V[V.HorizontalTop = 7] = "HorizontalTop", V[V.Bottom = 8] = "Bottom", V[V.LeftBottom = 9] = "LeftBottom", V[V.Vertical = 10] = "Vertical", V[V.LeftVertical = 11] = "LeftVertical", V[V.RightBottom = 12] = "RightBottom", V[V.HorizontalBottom = 13] = "HorizontalBottom", V[V.RightVertical = 14] = "RightVertical", V[V.All = 15] = "All"))(ui || (ui = {}));
  function ci(r, i) {
    if (!i.tileWidth || !i.tileHeight) throw new Error("Must provide tileWidth and tileHeight.");
    let u = Bt([sn(i.pos ?? E(0))]), m = r.length, f = 0, w = null, x = null, R = null, O = null, g = o((D) => D.x + D.y * f, "tile2Hash"), C = o((D) => E(Math.floor(D % f), Math.floor(D / f)), "hash2Tile"), L = o(() => {
      w = [];
      for (let D of u.children) U(D);
    }, "createSpatialMap"), U = o((D) => {
      let _ = g(D.tilePos);
      w[_] ? w[_].push(D) : w[_] = [D];
    }, "insertIntoSpatialMap"), I = o((D) => {
      let _ = g(D.tilePos);
      if (w[_]) {
        let k = w[_].indexOf(D);
        k >= 0 && w[_].splice(k, 1);
      }
    }, "removeFromSpatialMap"), S = o(() => {
      let D = false;
      for (let _ of u.children) {
        let k = u.pos2Tile(_.pos);
        (_.tilePos.x != k.x || _.tilePos.y != k.y) && (D = true, I(_), _.tilePos.x = k.x, _.tilePos.y = k.y, U(_));
      }
      D && u.trigger("spatial_map_changed");
    }, "updateSpatialMap"), F = o(() => {
      let D = u.getSpatialMap(), _ = u.numRows() * u.numColumns();
      x ? x.length = _ : x = new Array(_), x.fill(1, 0, _);
      for (let k = 0; k < D.length; k++) {
        let K = D[k];
        if (K) {
          let Z = 0;
          for (let ee of K) if (ee.isObstacle) {
            Z = 1 / 0;
            break;
          } else Z += ee.cost;
          x[k] = Z || 1;
        }
      }
    }, "createCostMap"), V = o(() => {
      let D = u.getSpatialMap(), _ = u.numRows() * u.numColumns();
      R ? R.length = _ : R = new Array(_), R.fill(15, 0, _);
      for (let k = 0; k < D.length; k++) {
        let K = D[k];
        if (K) {
          let Z = K.length, ee = 15;
          for (let ue = 0; ue < Z; ue++) ee |= K[ue].edgeMask;
          R[k] = ee;
        }
      }
    }, "createEdgeMap"), X = o(() => {
      let D = u.numRows() * u.numColumns(), _ = o((K, Z) => {
        let ee = [];
        for (ee.push(K); ee.length > 0; ) {
          let ue = ee.pop();
          z(ue).forEach((Te) => {
            O[Te] < 0 && (O[Te] = Z, ee.push(Te));
          });
        }
      }, "traverse");
      O ? O.length = D : O = new Array(D), O.fill(-1, 0, D);
      let k = 0;
      for (let K = 0; K < x.length; K++) {
        if (O[K] >= 0) {
          k++;
          continue;
        }
        _(K, k), k++;
      }
    }, "createConnectivityMap"), q = o((D, _) => x[_], "getCost"), Y = o((D, _) => {
      let k = C(D), K = C(_);
      return k.dist(K);
    }, "getHeuristic"), z = o((D, _) => {
      let k = [], K = Math.floor(D % f), Z = K > 0 && R[D] & 1 && x[D - 1] !== 1 / 0, ee = D >= f && R[D] & 2 && x[D - f] !== 1 / 0, ue = K < f - 1 && R[D] & 4 && x[D + 1] !== 1 / 0, Te = D < f * m - f - 1 && R[D] & 8 && x[D + f] !== 1 / 0;
      return _ ? (Z && (ee && k.push(D - f - 1), k.push(D - 1), Te && k.push(D + f - 1)), ee && k.push(D - f), ue && (ee && k.push(D - f + 1), k.push(D + 1), Te && k.push(D + f + 1)), Te && k.push(D + f)) : (Z && k.push(D - 1), ee && k.push(D - f), ue && k.push(D + 1), Te && k.push(D + f)), k;
    }, "getNeighbours"), Ie = { id: "level", tileWidth() {
      return i.tileWidth;
    }, tileHeight() {
      return i.tileHeight;
    }, spawn(D, ..._) {
      let k = E(..._), K = (() => {
        if (typeof D == "string") {
          if (i.tiles[D]) {
            if (typeof i.tiles[D] != "function") throw new Error("Level symbol def must be a function returning a component list");
            return i.tiles[D](k);
          } else if (i.wildcardTile) return i.wildcardTile(D, k);
        } else {
          if (Array.isArray(D)) return D;
          throw new Error("Expected a symbol or a component list");
        }
      })();
      if (!K) return null;
      let Z = false, ee = false;
      for (let Te of K) Te.id === "tile" && (ee = true), Te.id === "pos" && (Z = true);
      Z || K.push(sn()), ee || K.push(Vr());
      let ue = u.add(K);
      return Z && (ue.tilePosOffset = ue.pos.clone()), ue.tilePos = k, w && (U(ue), this.trigger("spatial_map_changed"), this.trigger("navigation_map_invalid")), ue;
    }, numColumns() {
      return f;
    }, numRows() {
      return m;
    }, levelWidth() {
      return f * this.tileWidth();
    }, levelHeight() {
      return m * this.tileHeight();
    }, tile2Pos(...D) {
      return E(...D).scale(this.tileWidth(), this.tileHeight());
    }, pos2Tile(...D) {
      let _ = E(...D);
      return E(Math.floor(_.x / this.tileWidth()), Math.floor(_.y / this.tileHeight()));
    }, getSpatialMap() {
      return w || L(), w;
    }, onSpatialMapChanged(D) {
      return this.on("spatial_map_changed", D);
    }, onNavigationMapInvalid(D) {
      return this.on("navigation_map_invalid", D);
    }, getAt(D) {
      w || L();
      let _ = g(D);
      return w[_] || [];
    }, raycast(D, _) {
      D = D.scale(1 / this.tileWidth(), 1 / this.tileHeight());
      let k = uo(D, _, (K) => {
        let Z = this.getAt(K);
        if (Z.some((ue) => ue.isObstacle)) return true;
        let ee;
        for (let ue of Z) if (ue.is("area")) {
          let wt = ue.worldArea().raycast(D, _);
          ee ? wt.fraction < ee.fraction && (ee = wt, ee.object = ue) : (ee = wt, ee.object = ue);
        }
        return ee || false;
      }, 64);
      return k && (k.point = k.point.scale(this.tileWidth(), this.tileHeight())), k;
    }, update() {
      w && S();
    }, invalidateNavigationMap() {
      x = null, R = null, O = null;
    }, onNavigationMapChanged(D) {
      return this.on("navigation_map_changed", D);
    }, getTilePath(D, _, k = {}) {
      var _a29;
      if (x || F(), R || V(), O || X(), D.x < 0 || D.x >= f || D.y < 0 || D.y >= m || _.x < 0 || _.x >= f || _.y < 0 || _.y >= m) return null;
      let K = g(D), Z = g(_);
      if (x[Z] === 1 / 0) return null;
      if (K === Z) return [];
      if (O[K] != -1 && O[K] !== O[Z]) return null;
      let ee = new Cn((ot, er) => ot.cost < er.cost);
      ee.insert({ cost: 0, node: K });
      let ue = /* @__PURE__ */ new Map();
      ue.set(K, K);
      let Te = /* @__PURE__ */ new Map();
      for (Te.set(K, 0); ee.length !== 0; ) {
        let ot = (_a29 = ee.remove()) == null ? void 0 : _a29.node;
        if (ot === Z) break;
        let er = z(ot, k.allowDiagonals);
        for (let Ct of er) {
          let tr = (Te.get(ot) || 0) + q(ot, Ct) + Y(Ct, Z);
          (!Te.has(Ct) || tr < Te.get(Ct)) && (Te.set(Ct, tr), ee.insert({ cost: tr, node: Ct }), ue.set(Ct, ot));
        }
      }
      let wt = [], qt = Z, Di = C(qt);
      for (wt.push(Di); qt !== K; ) {
        qt = ue.get(qt);
        let ot = C(qt);
        wt.push(ot);
      }
      return wt.reverse();
    }, getPath(D, _, k = {}) {
      let K = this.tileWidth(), Z = this.tileHeight(), ee = this.getTilePath(this.pos2Tile(D), this.pos2Tile(_), k);
      return ee ? [D, ...ee.slice(1, -1).map((ue) => ue.scale(K, Z).add(K / 2, Z / 2)), _] : null;
    } };
    return u.use(Ie), u.onNavigationMapInvalid(() => {
      u.invalidateNavigationMap(), u.trigger("navigation_map_changed");
    }), r.forEach((D, _) => {
      let k = D.split("");
      f = Math.max(k.length, f), k.forEach((K, Z) => {
        u.spawn(K, E(Z, _));
      });
    }), u;
  }
  o(ci, "addLevel");
  function li(r) {
    let i = l.canvas.captureStream(r), u = Q.ctx.createMediaStreamDestination();
    Q.masterNode.connect(u);
    let m = new MediaRecorder(i), f = [];
    return m.ondataavailable = (w) => {
      w.data.size > 0 && f.push(w.data);
    }, m.onerror = () => {
      Q.masterNode.disconnect(u), i.getTracks().forEach((w) => w.stop());
    }, m.start(), { resume() {
      m.resume();
    }, pause() {
      m.pause();
    }, stop() {
      return m.stop(), Q.masterNode.disconnect(u), i.getTracks().forEach((w) => w.stop()), new Promise((w) => {
        m.onstop = () => {
          w(new Blob(f, { type: "video/mp4" }));
        };
      });
    }, download(w = "kaboom.mp4") {
      this.stop().then((x) => br(w, x));
    } };
  }
  o(li, "record");
  function mi() {
    return document.activeElement === l.canvas;
  }
  o(mi, "isFocused");
  function kr(r) {
    r.destroy();
  }
  o(kr, "destroy");
  let Bt = A.root.add.bind(A.root), di = A.root.readd.bind(A.root), hi = A.root.removeAll.bind(A.root), Jn = A.root.get.bind(A.root), pi = A.root.wait.bind(A.root), fi = A.root.loop.bind(A.root), gi = A.root.query.bind(A.root), bi = A.root.tween.bind(A.root), yi = o(function(r, i) {
    if (A.layers) throw Error("Layers can only be assigned once.");
    let u = r.indexOf(i);
    if (u == -1) throw Error("The default layer name should be present in the layers list.");
    A.layers = r, A.defaultLayerIndex = u;
  }, "layers");
  function Nr(r = 2, i = 1) {
    let u = 0;
    return { require: ["scale"], update() {
      let m = Math.sin(u * r) * i;
      m < 0 && this.destroy(), this.scale = E(m), u += Xn();
    } };
  }
  o(Nr, "boom");
  let vi = ye(null, Cs), xi = ye(null, xs);
  function wi(r, i = {}) {
    let u = Bt([sn(r), Ur()]), m = (i.speed || 1) * 5, f = i.scale || 1;
    u.add([Dn(xi), an(0), Bn("center"), Nr(m, f), ...i.comps ?? []]);
    let w = u.add([Dn(vi), an(0), Bn("center"), Mn(), ...i.comps ?? []]);
    return w.wait(0.4 / m, () => w.use(Nr(m, f))), w.onDestroy(() => u.destroy()), u;
  }
  o(wi, "addKaboom");
  function _r() {
    A.root.update();
  }
  o(_r, "updateFrame");
  const _Zn = class _Zn {
    constructor(i, u, m, f = false) {
      __publicField(this, "source");
      __publicField(this, "target");
      __publicField(this, "displacement");
      __publicField(this, "resolved", false);
      this.source = i, this.target = u, this.displacement = m, this.resolved = f;
    }
    reverse() {
      return new _Zn(this.target, this.source, this.displacement.scale(-1), this.resolved);
    }
    hasOverlap() {
      return !this.displacement.isZero();
    }
    isLeft() {
      return this.displacement.cross(A.gravity || E(0, 1)) > 0;
    }
    isRight() {
      return this.displacement.cross(A.gravity || E(0, 1)) < 0;
    }
    isTop() {
      return this.displacement.dot(A.gravity || E(0, 1)) > 0;
    }
    isBottom() {
      return this.displacement.dot(A.gravity || E(0, 1)) < 0;
    }
    preventResolution() {
      this.resolved = true;
    }
  };
  o(_Zn, "Collision");
  let Zn = _Zn;
  function Ci() {
    let r = {}, i = t.hashGridSize || 64, u = new Le(), m = [];
    function f(w) {
      if (m.push(u.clone()), w.pos && u.translate(w.pos), w.scale && u.scale(w.scale), w.angle && u.rotate(w.angle), w.transform = u.clone(), w.c("area") && !w.paused) {
        let x = w, O = x.worldArea().bbox(), g = Math.floor(O.pos.x / i), C = Math.floor(O.pos.y / i), L = Math.ceil((O.pos.x + O.width) / i), U = Math.ceil((O.pos.y + O.height) / i), I = /* @__PURE__ */ new Set();
        for (let S = g; S <= L; S++) for (let F = C; F <= U; F++) if (!r[S]) r[S] = {}, r[S][F] = [x];
        else if (!r[S][F]) r[S][F] = [x];
        else {
          let V = r[S][F];
          e: for (let X of V) {
            if (X.paused || !X.exists() || I.has(X.id)) continue;
            for (let Y of x.collisionIgnore) if (X.is(Y)) continue e;
            for (let Y of X.collisionIgnore) if (x.is(Y)) continue e;
            let q = wo(x.worldArea(), X.worldArea());
            if (q) {
              let Y = new Zn(x, X, q);
              x.trigger("collideUpdate", X, Y);
              let z = Y.reverse();
              z.resolved = Y.resolved, X.trigger("collideUpdate", x, z);
            }
            I.add(X.id);
          }
          V.push(x);
        }
      }
      w.children.forEach(f), u = m.pop();
    }
    o(f, "checkObj"), f(A.root);
  }
  o(Ci, "checkFrame");
  function Ti() {
    let r = A.cam, i = B.fromAngle(Yt(0, 360)).scale(r.shake);
    r.shake = nt(r.shake, 0, 5 * Xn()), r.transform = new Le().translate(gn()).scale(r.scale).rotate(r.angle).translate((r.pos ?? gn()).scale(-1).add(i)), A.root.draw(), De();
  }
  o(Ti, "drawFrame");
  function Si() {
    let r = W();
    A.events.numListeners("loading") > 0 ? A.events.trigger("loading", r) : me(() => {
      let i = Re() / 2, u = 24, m = E(Re() / 2, Fe() / 2).sub(E(i / 2, u / 2));
      _e({ pos: E(0), width: Re(), height: Fe(), color: ie(0, 0, 0) }), _e({ pos: m, width: i, height: u, fill: false, outline: { width: 4 } }), _e({ pos: m, width: i * r, height: u });
    });
  }
  o(Si, "drawLoadScreen");
  function Hr(r, i) {
    me(() => {
      let u = E(8);
      Me(), pe(r);
      let m = Ge({ text: i, font: en, size: 16, pos: u, color: ie(255, 255, 255), fixed: true }), f = m.width + u.x * 2, w = m.height + u.x * 2;
      r.x + f >= Re() && pe(E(-f, 0)), r.y + w >= Fe() && pe(E(0, -w)), _e({ width: f, height: w, color: ie(0, 0, 0), radius: 4, opacity: 0.8, fixed: true }), Mt(m), Be();
    });
  }
  o(Hr, "drawInspectText");
  function Ei() {
    if (de.inspect) {
      let r = null;
      for (let i of A.root.get("*", { recursive: true })) if (i.c("area") && i.isHovering()) {
        r = i;
        break;
      }
      if (A.root.drawInspect(), r) {
        let i = [], u = r.inspect();
        for (let m in u) u[m] ? i.push(`${m}: ${u[m]}`) : i.push(`${m}`);
        Hr(Us(Mr()), i.join(`
`));
      }
      Hr(E(8), `FPS: ${de.fps()}`);
    }
    de.paused && me(() => {
      Me(), pe(Re(), 0), pe(-8, 8);
      let r = 32;
      _e({ width: r, height: r, anchor: "topright", color: ie(0, 0, 0), opacity: 0.8, radius: 4, fixed: true });
      for (let i = 1; i <= 2; i++) _e({ width: 4, height: r * 0.6, anchor: "center", pos: E(-r / 3 * i, r * 0.5), color: ie(255, 255, 255), radius: 2, fixed: true });
      Be();
    }), de.timeScale !== 1 && me(() => {
      Me(), pe(Re(), Fe()), pe(-8, -8);
      let r = 8, i = Ge({ text: de.timeScale.toFixed(1), font: en, size: 16, color: ie(255, 255, 255), pos: E(-r), anchor: "botright", fixed: true });
      _e({ width: i.width + r * 2 + r * 4, height: i.height + r * 2, anchor: "botright", color: ie(0, 0, 0), opacity: 0.8, radius: 4, fixed: true });
      for (let u = 0; u < 2; u++) {
        let m = de.timeScale < 1;
        pn({ p1: E(-i.width - r * (m ? 2 : 3.5), -r), p2: E(-i.width - r * (m ? 2 : 3.5), -r - i.height), p3: E(-i.width - r * (m ? 3.5 : 2), -r - i.height / 2), pos: E(-u * r * 1 + (m ? -r * 0.5 : 0), 0), color: ie(255, 255, 255), fixed: true });
      }
      Mt(i), Be();
    }), de.curRecording && me(() => {
      Me(), pe(0, Fe()), pe(24, -24), Ut({ radius: 12, color: ie(255, 0, 0), opacity: sr(0, 1, l.time() * 4), fixed: true }), Be();
    }), de.showLog && A.logs.length > 0 && me(() => {
      var _a29;
      Me(), pe(0, Fe()), pe(8, -8);
      let r = 8, i = [];
      for (let m of A.logs) {
        let f = "", w = m.msg instanceof Error ? "error" : "info";
        f += `[time]${m.time.toFixed(2)}[/time]`, f += " ", f += `[${w}]${((_a29 = m.msg) == null ? void 0 : _a29.toString) ? m.msg.toString() : m.msg}[/${w}]`, i.push(f);
      }
      A.logs = A.logs.filter((m) => l.time() - m.time < (t.logTime || 4));
      let u = Ge({ text: i.join(`
`), font: en, pos: E(r, -r), anchor: "botleft", size: 16, width: Re() * 0.6, lineSpacing: r / 2, fixed: true, styles: { time: { color: ie(127, 127, 127) }, info: { color: ie(255, 255, 255) }, error: { color: ie(255, 0, 127) } } });
      _e({ width: u.width + r * 2, height: u.height + r * 2, anchor: "botleft", color: ie(0, 0, 0), radius: 4, opacity: 0.8, fixed: true }), Mt(u), Be();
    });
  }
  o(Ei, "drawDebug");
  function Oi(r) {
    A.events.on("loading", r);
  }
  o(Oi, "onLoading");
  function Ai(r) {
    l.onResize(r);
  }
  o(Ai, "onResize");
  function Ri(r) {
    A.events.on("error", r);
  }
  o(Ri, "onError");
  function Pi(r) {
    console.error(r), Q.ctx.suspend(), l.run(() => {
      kt(), me(() => {
        let m = Re(), f = Fe(), w = { size: 36, width: m - 32 * 2, letterSpacing: 4, lineSpacing: 4, font: en, fixed: true };
        _e({ width: m, height: f, color: ie(0, 0, 255), fixed: true });
        let x = Ge({ ...w, text: "Error", pos: E(32), color: ie(255, 128, 0), fixed: true });
        Mt(x), Dt({ ...w, text: r.message, pos: E(32, 32 + x.height + 16), fixed: true }), Be(), A.events.trigger("error", r);
      }), Nt();
    });
  }
  o(Pi, "handleErr");
  function Vi(r) {
    M.push(r);
  }
  o(Vi, "onCleanup");
  function Ui() {
    A.events.onOnce("frameEnd", () => {
      l.quit(), y.clear(y.COLOR_BUFFER_BIT | y.DEPTH_BUFFER_BIT | y.STENCIL_BUFFER_BIT);
      let r = y.getParameter(y.MAX_TEXTURE_IMAGE_UNITS);
      for (let i = 0; i < r; i++) y.activeTexture(y.TEXTURE0 + i), y.bindTexture(y.TEXTURE_2D, null), y.bindTexture(y.TEXTURE_CUBE_MAP, null);
      y.bindBuffer(y.ARRAY_BUFFER, null), y.bindBuffer(y.ELEMENT_ARRAY_BUFFER, null), y.bindRenderbuffer(y.RENDERBUFFER, null), y.bindFramebuffer(y.FRAMEBUFFER, null), P.destroy(), M.forEach((i) => i());
    });
  }
  o(Ui, "quit");
  let bn = true;
  l.run(() => {
    try {
      N.loaded || W() === 1 && !bn && (N.loaded = true, A.events.trigger("load")), !N.loaded && t.loadingScreen !== false || bn ? (kt(), Si(), Nt()) : (de.paused || _r(), Ci(), kt(), Ti(), t.debug !== false && Ei(), Nt()), bn && (bn = false), A.events.trigger("frameEnd");
    } catch (r) {
      Pi(r);
    }
  });
  function Kr() {
    let r = h, i = y.drawingBufferWidth / r, u = y.drawingBufferHeight / r;
    if (t.letterbox) {
      if (!t.width || !t.height) throw new Error("Letterboxing requires width and height defined.");
      let m = i / u, f = t.width / t.height;
      if (m > f) {
        let w = u * f, x = (i - w) / 2;
        v.viewport = { x, y: 0, width: w, height: u };
      } else {
        let w = i / f, x = (u - w) / 2;
        v.viewport = { x: 0, y: x, width: i, height: w };
      }
      return;
    }
    if (t.stretch && (!t.width || !t.height)) throw new Error("Stretching requires width and height defined.");
    v.viewport = { x: 0, y: 0, width: i, height: u };
  }
  o(Kr, "updateViewport");
  function qr() {
    l.onHide(() => {
      t.backgroundAudio || Q.ctx.suspend();
    }), l.onShow(() => {
      !t.backgroundAudio && !de.paused && Q.ctx.resume();
    }), l.onResize(() => {
      if (l.isFullscreen()) return;
      let r = t.width && t.height;
      r && !t.stretch && !t.letterbox || (n.width = n.offsetWidth * h, n.height = n.offsetHeight * h, Kr(), r || (v.frameBuffer.free(), v.frameBuffer = new At(P, y.drawingBufferWidth, y.drawingBufferHeight), v.width = y.drawingBufferWidth / h / s, v.height = y.drawingBufferHeight / h / s));
    }), t.debug !== false && (l.onKeyPress(t.debugKey ?? "f1", () => de.inspect = !de.inspect), l.onKeyPress("f2", () => de.clearLog()), l.onKeyPress("f8", () => de.paused = !de.paused), l.onKeyPress("f7", () => {
      de.timeScale = Qn(tt(de.timeScale - 0.2, 0, 2), 1);
    }), l.onKeyPress("f9", () => {
      de.timeScale = Qn(tt(de.timeScale + 0.2, 0, 2), 1);
    }), l.onKeyPress("f10", () => de.stepFrame())), t.burp && l.onKeyPress("b", () => dn());
  }
  if (o(qr, "initEvents"), Kr(), qr(), Ze = { _k: { kaboomCtx: Ze, app: l, game: A, isFixed: Ir, toFixed: Qn, getViewportScale: Ce, getRenderProps: ti, resolveSprite: cn, drawTexture: _t, calcTransform: Gr }, VERSION: xa, loadRoot: se, loadProgress: W, loadSprite: ye, loadSpriteAtlas: be, loadSound: ft, loadMusic: Ae, loadBitmapFont: le, loadFont: ae, loadShader: ze, loadShaderURL: We, loadAseprite: qe, loadPedit: Ke, loadBean: Ue, loadJSON: ne, load: te, getSprite: Ne, getSound: ct, getFont: Ye, getBitmapFont: Vt, getShader: un, getAsset: Fn, Asset: Ve, SpriteData: j, SoundData: H, width: Re, height: Fe, center: gn, dt: Xn, time: l.time, screenshot: l.screenshot, record: li, isFocused: mi, setCursor: l.setCursor, getCursor: l.getCursor, setCursorLocked: l.setCursorLocked, isCursorLocked: l.isCursorLocked, setFullscreen: l.setFullscreen, isFullscreen: l.isFullscreen, isTouchscreen: l.isTouchscreen, onLoad: ni, onLoading: Oi, onResize: Ai, onGamepadConnect: l.onGamepadConnect, onGamepadDisconnect: l.onGamepadDisconnect, onError: Ri, onCleanup: Vi, camPos: Ds, camScale: Ms, camFlash: Gs, camRot: Bs, camTransform: Fs, shake: Is, toScreen: Ls, toWorld: js, setGravity: Ys, getGravity: $s, setGravityDirection: Qs, getGravityDirection: Js, setBackground: Zs, getBackground: ei, getGamepads: l.getGamepads, getTreeRoot: Ps, add: Bt, make: Yn, destroy: kr, destroyAll: hi, get: Jn, query: gi, readd: di, pos: sn, scale: an, rotate: bs, color: Ar, opacity: Rr, anchor: Bn, area: ls, sprite: Dn, text: rs, polygon: es, rect: Pr, circle: Yo, uvquad: os, outline: Zo, body: ms, doubleJump: ds, shader: ns, timer: Mn, fixed: Dr, stay: Ur, health: is, lifespan: as, named: us, state: cs, z: ys, layer: ps, move: fs, offscreen: gs, follow: hs, fadeIn: Qo, mask: Jo, drawon: $o, raycast: ts, tile: Vr, agent: ss, on: dt, onUpdate: ks, onDraw: Ns, onAdd: $n, onDestroy: Fr, onClick: qs, onCollide: _s, onCollideUpdate: Hs, onCollideEnd: Ks, onHover: zs, onHoverUpdate: Ws, onHoverEnd: Xs, onKeyDown: l.onKeyDown, onKeyPress: l.onKeyPress, onKeyPressRepeat: l.onKeyPressRepeat, onKeyRelease: l.onKeyRelease, onMouseDown: l.onMouseDown, onMousePress: l.onMousePress, onMouseRelease: l.onMouseRelease, onMouseMove: l.onMouseMove, onCharInput: l.onCharInput, onTouchStart: l.onTouchStart, onTouchMove: l.onTouchMove, onTouchEnd: l.onTouchEnd, onScroll: l.onScroll, onHide: l.onHide, onShow: l.onShow, onGamepadButtonDown: l.onGamepadButtonDown, onGamepadButtonPress: l.onGamepadButtonPress, onGamepadButtonRelease: l.onGamepadButtonRelease, onGamepadStick: l.onGamepadStick, onButtonPress: l.onButtonPress, onButtonDown: l.onButtonDown, onButtonRelease: l.onButtonRelease, mousePos: Mr, mouseDeltaPos: l.mouseDeltaPos, isKeyDown: l.isKeyDown, isKeyPressed: l.isKeyPressed, isKeyPressedRepeat: l.isKeyPressedRepeat, isKeyReleased: l.isKeyReleased, isMouseDown: l.isMouseDown, isMousePressed: l.isMousePressed, isMouseReleased: l.isMouseReleased, isMouseMoved: l.isMouseMoved, isGamepadButtonPressed: l.isGamepadButtonPressed, isGamepadButtonDown: l.isGamepadButtonDown, isGamepadButtonReleased: l.isGamepadButtonReleased, getGamepadStick: l.getGamepadStick, isButtonPressed: l.isButtonPressed, isButtonDown: l.isButtonDown, isButtonReleased: l.isButtonReleased, setButton: l.setButton, getButton: l.getButton, charInputted: l.charInputted, loop: fi, wait: pi, play: mn, volume: jn, burp: dn, audioCtx: Q.ctx, Line: je, Rect: ce, Circle: ke, Ellipse: Qe, Polygon: Pe, Vec2: B, Color: oe, Mat4: Le, Quad: he, RNG: Xt, rand: Yt, randi: ir, randSeed: $r, vec2: E, rgb: ie, hsl2rgb: Yr, quad: ge, choose: Zr, chooseMultiple: Jr, shuffle: ar, chance: Qr, lerp: nt, tween: bi, easings: Lt, map: st, mapc: Xr, wave: sr, deg2rad: ve, rad2deg: ht, clamp: tt, evaluateQuadratic: co, evaluateQuadraticFirstDerivative: lo, evaluateQuadraticSecondDerivative: mo, evaluateBezier: wn, evaluateBezierFirstDerivative: ho, evaluateBezierSecondDerivative: po, evaluateCatmullRom: fo, evaluateCatmullRomFirstDerivative: go, curveLengthApproximation: pr, normalizedCurve: bo, easingSteps: xo, easingLinear: yo, easingCubicBezier: vo, testLineLine: vn, testRectRect: ur, testRectLine: xn, testRectPoint: cr, testCirclePolygon: $t, testLinePoint: lr, testLineCircle: Ft, isConvex: To, triangulate: fr, drawSprite: zn, drawText: Dt, formatText: Ge, drawRect: _e, drawLine: vt, drawLines: et, drawTriangle: pn, drawCircle: Ut, drawEllipse: Kt, drawUVQuad: bt, drawPolygon: d, drawCurve: Ht, drawBezier: hn, drawFormattedText: Mt, drawMasked: G, drawSubtracted: $, pushTransform: Me, popTransform: Be, pushTranslate: pe, pushScale: gt, pushRotate: mt, pushMatrix: qn, usePostEffect: Hn, makeCanvas: Nn, debug: de, scene: ri, getSceneName: ii, go: oi, onSceneLeave: si, layers: yi, addLevel: ci, getData: ai, setData: Lr, download: Sn, downloadJSON: Oo, downloadText: gr, downloadBlob: br, plug: jr, ASCII_CHARS: Er, canvas: l.canvas, addKaboom: wi, LEFT: B.LEFT, RIGHT: B.RIGHT, UP: B.UP, DOWN: B.DOWN, RED: oe.RED, GREEN: oe.GREEN, BLUE: oe.BLUE, YELLOW: oe.YELLOW, MAGENTA: oe.MAGENTA, CYAN: oe.CYAN, WHITE: oe.WHITE, BLACK: oe.BLACK, quit: Ui, Event: Se, EventHandler: at, EventController: it }, t.plugins && t.plugins.forEach(jr), t.global !== false) for (let r in Ze) window[r] = Ze[r];
  return t.focus !== false && l.canvas.focus(), Ze;
}, "kaplay");
var vm = Sa;
export {
  Pt as anchorPt,
  vm as default,
  re as getKaboomContext,
  Ta as isKaboomCtx
};
//# sourceMappingURL=kaplay.js.map
